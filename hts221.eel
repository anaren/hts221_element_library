{
    "author": "STMicroelectronics, Anaren Inc.",
    "categories": [
        "New",
        "Humidity",
        "Temperature",
        "Sensor"
    ],
    "code": {
        "connected": " \n",
        "global": "",
        "interval": " \n",
        "setup": "\t//HTS221 Init structure definition\n\tHTS221_Init_st hts221Init;\n\t//Init HTS221 \n\tHTS221_Setup(&hts221Init);"
    },
    "config": {
        "file": "hts221_config.h",
        "values": {
            "i2c_address": {
                "input": "Combo",
                "name": "I2C Address (7 bit)",
                "options": [
                    "0xbe",
                    "0xbd"
                ],
                "prefix": "#define AIR_HTS221_I2C_ADDRESS ",
                "regex": "^[a-zA-Z0-9_.]*$",
                "value": "0xbe"
            }
        }
    },
    "description": "The HTS221 is an ultra compact sensor for relative humidity and temperature. It includes a sensing element and a mixed signal ASIC to provide the measurement information through digital serial interfaces.",
    "elements": {
        "humidity": {
            "code": "\tuint16_t htsHumid;\n\n\t/**\n\tRead the relative humidity.  When set to Continuous Conversion mode, the\n\tdevice periodically performs humidity conversions at a predefined rate.  This\n\tfunction calulates the humidity using only the most recent conversion value.\n\t@param htsHumid int16_t to hold calculated humidity\n\t@param htsTemp uint16_t to hold calculated temperature\n\t@return htsHumid returns humidity value that must be divided by 10 to get the value in [%].\n\t*/\n\n\tHTS221_Get_Humidity(&htsHumid);\n\n\treturn htsHumid / 10.0f; \n",
            "icon": "data:image/png;base64,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\n",
            "inputType": "void",
            "label": "Humidity",
            "language": {
                "en": {
                    "label": "Humidity"
                }
            },
            "returnType": "float"
        },
        "temperature": {
            "code": "\tint16_t htsTemp;\n\n\t/**\n\tRead the temperature.  When set to Continuous Conversion mode, the\n\tdevice periodically performs temperature conversions at a predefined rate.  This\n\tfunction calulates the temperature using only the most recent conversion value.\n\t@param htsHumid int16_t to hold calculated humidity\n\t@return htsTemp temperature value that must be divided by 10 to get the value in ['C]\n\t*/\n\n\tHTS221_Get_Temperature(&htsTemp);\n\n\treturn htsTemp / 10.0f; \n",
            "icon": "data:image/png;base64,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\nYII=\n",
            "inputType": "void",
            "label": "Temperature",
            "language": {
                "en": {
                    "label": "Temperature"
                }
            },
            "returnType": "float"
        }
    },
    "files": {
        "common": {
            "headers": {
                "hts221.h": "/**\n******************************************************************************\n* @file    HTS221_Driver.h\n* @author  HESA Application Team\n* @version 1.0.0\n* @date    07/04/2014\n* @brief   HTS221 driver header file\n\n* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS\n* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE\n* TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY\n* DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING\n* FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE\n* CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.\n*\n* THIS SOURCE CODE IS PROTECTED BY A LICENSE.\n* FOR MORE INFORMATION PLEASE CAREFULLY READ THE LICENSE AGREEMENT FILE LOCATED\n* IN THE ROOT DIRECTORY OF THIS FIRMWARE PACKAGE.\n*\n* <h2><center>&copy; COPYRIGHT 2013 STMicroelectronics</center></h2>\n\n******************************************************************************\n*/\n\n/* Define to prevent recursive inclusion -------------------------------------*/\n#ifndef __HTS221_DRIVER__H\n#define __HTS221_DRIVER__H\n\n#include \"../i2c/i2c.h\"\n#include \"hts221_config.h\"\n#include <stdint.h>\n\n/* Uncomment the line below to expanse the \"assert_param\" macro in the drivers code */\n// #define USE_FULL_ASSERT_HTS221\n\n/* Exported macro ------------------------------------------------------------*/\n#ifdef  USE_FULL_ASSERT_HTS221\n\n/**\n* @brief  The assert_param macro is used for function's parameters check.\n* @param  expr: If expr is false, it calls assert_failed function which reports\n*         the name of the source file and the source line number of the call\n*         that failed. If expr is true, it returns no value.\n* @retval None\n*/\n#define HTS221_assert_param(expr) ((expr) ? (void)0 : HTS221_assert_failed((uint8_t *)__FILE__, __LINE__))\n/* Exported functions ------------------------------------------------------- */\nvoid HTS221_assert_failed(uint8_t* file, uint32_t line);\n#else\n#define HTS221_assert_param(expr) ((void)0)\n#endif /* USE_FULL_ASSERT_HTS221 */\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/** @addtogroup Environmental_Sensor\n* @{\n*/\n\n/** @addtogroup HTS221_DRIVER\n* @{\n*/\n\n/* Exported Types -------------------------------------------------------------*/\n/** @defgroup HTS221_Exported_Types\n* @{\n*/\n\n\n/**\n* @brief  Error code type.\n*/\ntypedef enum {HTS221_OK = (uint8_t)0, HTS221_ERROR = !HTS221_OK} HTS221_Error_et;\n\n/**\n* @brief  State type.\n*/\ntypedef enum {HTS221_DISABLE = (uint8_t)0, HTS221_ENABLE = !HTS221_DISABLE} HTS221_State_et;\n#define IS_HTS221_State(MODE) ((MODE == HTS221_ENABLE) || (MODE == HTS221_DISABLE))\n\n/**\n* @brief  Bit status type.\n*/\ntypedef enum {HTS221_RESET = (uint8_t)0, HTS221_SET = !HTS221_RESET} HTS221_BitStatus_et;\n#define IS_HTS221_BitStatus(MODE) ((MODE == HTS221_RESET) || (MODE == HTS221_SET))\n\n/**\n* @brief  Humidity average.\n*/\ntypedef enum {\n  HTS221_AVGH_4         = (uint8_t)0x00,         /*!< Internal average on 4 samples */\n  HTS221_AVGH_8         = (uint8_t)0x01,         /*!< Internal average on 8 samples */\n  HTS221_AVGH_16        = (uint8_t)0x02,         /*!< Internal average on 16 samples */\n  HTS221_AVGH_32        = (uint8_t)0x03,         /*!< Internal average on 32 samples */\n  HTS221_AVGH_64        = (uint8_t)0x04,         /*!< Internal average on 64 samples */\n  HTS221_AVGH_128       = (uint8_t)0x05,         /*!< Internal average on 128 samples */\n  HTS221_AVGH_256       = (uint8_t)0x06,         /*!< Internal average on 256 samples */\n  HTS221_AVGH_512       = (uint8_t)0x07          /*!< Internal average on 512 samples */\n}HTS221_Avgh_et;\n#define IS_HTS221_AVGH(AVGH) ((AVGH == HTS221_AVGH_4) || (AVGH == HTS221_AVGH_8) || \\\n                              (AVGH == HTS221_AVGH_16) || (AVGH == HTS221_AVGH_32) || \\\n                              (AVGH == HTS221_AVGH_64) || (AVGH == HTS221_AVGH_128) || \\\n                              (AVGH == HTS221_AVGH_256) || (AVGH == HTS221_AVGH_512))\n\n/**\n* @brief  Temperature average.\n*/\ntypedef enum {\n  HTS221_AVGT_2         = (uint8_t)0x00,        /*!< Internal average on 2 samples */\n  HTS221_AVGT_4         = (uint8_t)0x08,        /*!< Internal average on 4 samples */\n  HTS221_AVGT_8         = (uint8_t)0x10,        /*!< Internal average on 8 samples */\n  HTS221_AVGT_16        = (uint8_t)0x18,        /*!< Internal average on 16 samples */\n  HTS221_AVGT_32        = (uint8_t)0x20,        /*!< Internal average on 32 samples */\n  HTS221_AVGT_64        = (uint8_t)0x28,        /*!< Internal average on 64 samples */\n  HTS221_AVGT_128       = (uint8_t)0x30,        /*!< Internal average on 128 samples */\n  HTS221_AVGT_256       = (uint8_t)0x38         /*!< Internal average on 256 samples */\n}HTS221_Avgt_et;\n#define IS_HTS221_AVGT(AVGT) ((AVGT == HTS221_AVGT_2) || (AVGT == HTS221_AVGT_4) || \\\n                              (AVGT == HTS221_AVGT_8) || (AVGT == HTS221_AVGT_16) || \\\n                              (AVGT == HTS221_AVGT_32) || (AVGT == HTS221_AVGT_64) || \\\n                              (AVGT == HTS221_AVGT_128) || (AVGT == HTS221_AVGT_256))\n\n/**\n* @brief  Output data rate configuration.\n*/\ntypedef enum {\n  HTS221_ODR_ONE_SHOT  = (uint8_t)0x00,         /*!< Output Data Rate: one shot */\n  HTS221_ODR_1HZ       = (uint8_t)0x01,         /*!< Output Data Rate: 1Hz */\n  HTS221_ODR_7HZ       = (uint8_t)0x02,         /*!< Output Data Rate: 7Hz */\n  HTS221_ODR_12_5HZ    = (uint8_t)0x03,         /*!< Output Data Rate: 12.5Hz */\n} HTS221_Odr_et;\n#define IS_HTS221_ODR(ODR) ((ODR == HTS221_ODR_ONE_SHOT) || (ODR == HTS221_ODR_1HZ) || \\\n                            (ODR == HTS221_ODR_7HZ) || (ODR == HTS221_ODR_12_5HZ))\n\n\n/**\n* @brief  Push-pull/Open Drain selection on DRDY pin.\n*/\ntypedef enum {\n  HTS221_PUSHPULL   = (uint8_t)0x00,   /*!< DRDY pin in push pull */\n  HTS221_OPENDRAIN  = (uint8_t)0x40    /*!< DRDY pin in open drain */\n}HTS221_OutputType_et;\n#define IS_HTS221_OutputType(MODE) ((MODE == HTS221_PUSHPULL) || (MODE == HTS221_OPENDRAIN))\n\n/**\n* @brief  Active level of DRDY pin.\n*/\ntypedef enum {\n  HTS221_HIGH_LVL   = (uint8_t)0x00,   /*!< HIGH state level for DRDY pin */\n  HTS221_LOW_LVL    = (uint8_t)0x80    /*!< LOW state level for DRDY pin */\n}HTS221_DrdyLevel_et;\n#define IS_HTS221_DrdyLevelType(MODE) ((MODE == HTS221_HIGH_LVL) || (MODE == HTS221_LOW_LVL))\n\n/**\n* @brief  Driver Version Info structure definition.\n*/\ntypedef struct\n{\n  uint8_t   Major;\n  uint8_t   Minor;\n  uint8_t   Point;\n}HTS221_DriverVersion_st;\n\n\n/**\n* @brief  HTS221 Init structure definition.\n*/\ntypedef struct\n{\n  HTS221_Avgh_et        avg_h;            /*!< Humidity average */\n  HTS221_Avgt_et        avg_t;            /*!< Temperature average */\n  HTS221_Odr_et         odr;              /*!< Output data rate */\n  HTS221_State_et       bdu_status;       /*!< HTS221_ENABLE/HTS221_DISABLE the block data update */\n  HTS221_State_et       heater_status;    /*!< HTS221_ENABLE/HTS221_DISABLE the internal heater */\n\n  HTS221_DrdyLevel_et   irq_level;        /*!< HTS221_HIGH_LVL/HTS221_LOW_LVL the level for DRDY pin */\n  HTS221_OutputType_et  irq_output_type;  /*!< Output configuration for DRDY pin */\n  HTS221_State_et       irq_enable;       /*!< HTS221_ENABLE/HTS221_DISABLE interrupt on DRDY pin */\n}HTS221_Init_st;\n\n/**\n* @}\n*/\n\n\n/* Exported Constants ---------------------------------------------------------*/\n/** @defgroup HTS221_Exported_Constants\n* @{\n*/\n\n/**\n* @brief  Bitfield positioning.\n*/\n#define HTS221_BIT(x) ((uint8_t)x)\n\n/**\n* @brief  I2C address.\n*/\n#define HTS221_I2C_ADDRESS  (uint8_t)AIR_HTS221_I2C_ADDRESS\n\n/**\n* @brief  I2C baudrate.\n*/\n#define HTS221_I2C_BAUD  400\n\n/**\n* @brief  Driver version.\n*/\n#define HTS221_DRIVER_VERSION_MAJOR (uint8_t)1\n#define HTS221_DRIVER_VERSION_MINOR (uint8_t)0\n#define HTS221_DRIVER_VERSION_POINT (uint8_t)0\n\n/**\n* @addtogroup HTS221_Registers\n* @{\n*/\n\n\n/**\n* @brief Device Identification register.\n* \\code\n* Read\n* Default value: 0xBC\n* 7:0 This read-only register contains the device identifier for HTS221.\n* \\endcode\n*/\n#define HTS221_WHO_AM_I_REG          (uint8_t)0x0F\n\n/**\n* @brief Device Identification value.\n*/\n#define HTS221_WHO_AM_I_VAL         (uint8_t)0xBC\n\n\n/**\n* @brief Humidity and temperature average mode register.\n* \\code\n* Read/write\n* Default value: 0x1B\n* 7:6 Reserved.\n* 5:3 AVGT2-AVGT1-AVGT0: Select the temperature internal average.\n*\n*      AVGT2 | AVGT1 | AVGT0 | Nr. Internal Average\n*   ----------------------------------------------------\n*       0    |   0   |   0   |    2\n*       0    |   0   |   1   |    4\n*       0    |   1   |   0   |    8\n*       0    |   1   |   1   |    16\n*       1    |   0   |   0   |    32\n*       1    |   0   |   1   |    64\n*       1    |   1   |   0   |    128\n*       1    |   1   |   1   |    256\n*\n* 2:0 AVGH2-AVGH1-AVGH0: Select humidity internal average.\n*      AVGH2 | AVGH1 |  AVGH0 | Nr. Internal Average\n*   ------------------------------------------------------\n*       0    |   0   |   0   |    4\n*       0    |   0   |   1   |    8\n*       0    |   1   |   0   |    16\n*       0    |   1   |   1   |    32\n*       1    |   0   |   0   |    64\n*       1    |   0   |   1   |    128\n*       1    |   1   |   0   |    256\n*       1    |   1   |   1   |    512\n*\n* \\endcode\n*/\n#define HTS221_AV_CONF_REG        (uint8_t)0x10\n\n#define HTS221_AVGT_BIT           HTS221_BIT(3)\n#define HTS221_AVGH_BIT           HTS221_BIT(0)\n\n#define HTS221_AVGH_MASK          (uint8_t)0x07\n#define HTS221_AVGT_MASK          (uint8_t)0x38\n\n/**\n* @brief Control register 1.\n* \\code\n* Read/write\n* Default value: 0x00\n* 7 PD: power down control. 0 - power down mode; 1 - active mode.\n* 6:3 Reserved.\n* 2 BDU: block data update. 0 - continuous update; 1 - output registers not updated until MSB and LSB reading.\n* 1:0 ODR1, ODR0: output data rate selection.\n*\n*   ODR1  | ODR0  | Humidity output data-rate(Hz)  | Pressure output data-rate(Hz)\n*   ----------------------------------------------------------------------------------\n*     0   |   0   |         one shot               |         one shot\n*     0   |   1   |            1                   |            1\n*     1   |   0   |            7                   |            7\n*     1   |   1   |           12.5                 |           12.5\n*\n* \\endcode\n*/\n#define HTS221_CTRL_REG1      (uint8_t)0x20\n\n#define HTS221_PD_BIT          HTS221_BIT(7)\n#define HTS221_BDU_BIT         HTS221_BIT(2)\n#define HTS221_ODR_BIT         HTS221_BIT(0)\n\n#define HTS221_PD_MASK        (uint8_t)0x80\n#define HTS221_BDU_MASK       (uint8_t)0x04\n#define HTS221_ODR_MASK       (uint8_t)0x03\n\n/**\n* @brief Control register 2.\n* \\code\n* Read/write\n* Default value: 0x00\n* 7 BOOT:  Reboot memory content. 0: normal mode; 1: reboot memory content. Self-cleared upon completation.\n* 6:2 Reserved.\n* 1 HEATHER: 0: heater enable; 1: heater disable.\n* 0 ONE_SHOT: 0: waiting for start of conversion; 1: start for a new dataset. Self-cleared upon completation.\n* \\endcode\n*/\n#define HTS221_CTRL_REG2      (uint8_t)0x21\n\n#define HTS221_BOOT_BIT        HTS221_BIT(7)\n#define HTS221_HEATHER_BIT     HTS221_BIT(1)\n#define HTS221_ONESHOT_BIT     HTS221_BIT(0)\n\n#define HTS221_BOOT_MASK      (uint8_t)0x80\n#define HTS221_HEATHER_MASK   (uint8_t)0x02\n#define HTS221_ONE_SHOT_MASK  (uint8_t)0x01\n\n/**\n* @brief Control register 3.\n* \\code\n* Read/write\n* Default value: 0x00\n* 7 DRDY_H_L: Interrupt edge. 0: active high, 1: active low.\n* 6 PP_OD: Push-Pull/OpenDrain selection on interrupt pads. 0: push-pull; 1: open drain.\n* 5:3 Reserved.\n* 2 DRDY: interrupt config. 0: disable, 1: enable.\n* \\endcode\n*/\n#define HTS221_CTRL_REG3      (uint8_t)0x22\n\n#define HTS221_DRDY_H_L_BIT    HTS221_BIT(7)\n#define HTS221_PP_OD_BIT       HTS221_BIT(6)\n#define HTS221_DRDY_BIT        HTS221_BIT(2)\n\n#define HTS221_DRDY_H_L_MASK  (uint8_t)0x80\n#define HTS221_PP_OD_MASK     (uint8_t)0x40\n#define HTS221_DRDY_MASK      (uint8_t)0x04\n\n/**\n* @brief  Status register.\n* \\code\n* Read\n* Default value: 0x00\n* 7:2 Reserved.\n* 1 H_DA: Humidity data available. 0: new data for humidity is not yet available; 1: new data for humidity is available.\n* 0 T_DA: Temperature data available. 0: new data for temperature is not yet available; 1: new data for temperature is available.\n* \\endcode\n*/\n#define HTS221_STATUS_REG    (uint8_t)0x27\n\n#define HTS221_H_DA_BIT       HTS221_BIT(1)\n#define HTS221_T_DA_BIT       HTS221_BIT(0)\n\n#define HTS221_HDA_MASK      (uint8_t)0x02\n#define HTS221_TDA_MASK      (uint8_t)0x01\n\n/**\n* @brief  Humidity data (LSB).\n* \\code\n* Read\n* Default value: 0x00.\n* HOUT7 - HOUT0: Humidity data LSB (2's complement).\n* \\endcode\n*/\n#define HTS221_HR_OUT_L_REG        (uint8_t)0x28\n\n/**\n* @brief  Humidity data (MSB).\n* \\code\n* Read\n* Default value: 0x00.\n* HOUT15 - HOUT8: Humidity data MSB (2's complement).\n* \\endcode\n*/\n#define HTS221_HR_OUT_H_REG        (uint8_t)0x29\n\n\n/**\n* @brief  Temperature data (LSB).\n* \\code\n* Read\n* Default value: 0x00.\n* TOUT7 - TOUT0: temperature data LSB.\n* \\endcode\n*/\n#define HTS221_TEMP_OUT_L_REG         (uint8_t)0x2A\n\n/**\n* @brief  Temperature data (MSB).\n* \\code\n* Read\n* Default value: 0x00.\n* TOUT15 - TOUT8: temperature data MSB.\n* \\endcode\n*/\n#define HTS221_TEMP_OUT_H_REG         (uint8_t)0x2B\n\n/**\n* @brief  Calibration registers.\n* \\code\n* Read\n* \\endcode\n*/\n#define HTS221_H0_RH_X2        (uint8_t)0x30\n#define HTS221_H1_RH_X2        (uint8_t)0x31\n#define HTS221_T0_DEGC_X8      (uint8_t)0x32\n#define HTS221_T1_DEGC_X8      (uint8_t)0x33\n#define HTS221_T0_T1_DEGC_H2   (uint8_t)0x35\n#define HTS221_H0_T0_OUT_L     (uint8_t)0x36\n#define HTS221_H0_T0_OUT_H     (uint8_t)0x37\n#define HTS221_H1_T0_OUT_L     (uint8_t)0x3A\n#define HTS221_H1_T0_OUT_H     (uint8_t)0x3B\n#define HTS221_T0_OUT_L        (uint8_t)0x3C\n#define HTS221_T0_OUT_H        (uint8_t)0x3D\n#define HTS221_T1_OUT_L        (uint8_t)0x3E\n#define HTS221_T1_OUT_H        (uint8_t)0x3F\n\n\n/**\n* @}\n*/\n\n\n/**\n* @}\n*/\n\n\n/* Exported Functions -------------------------------------------------------------*/\n/** @defgroup HTS221_Exported_Functions\n* @{\n*/\n\n#define HTS221_HalInit                                  HAL_Init_I2C\n#define HTS221_HalDeInit                                HAL_DeInit_I2C\n\n// the user must redefine the proper HTS221_ReadReg\n//#define HTS221_ReadReg(RegAddr, NumByteToRead, Data)    HAL_ReadReg(HTS221_I2C_ADDRESS, RegAddr, NumByteToRead, Data)\n\n// the user must redefine the proper HTS221_WriteReg\n//#define HTS221_WriteReg(RegAddr, NumByteToWrite, Data)  HAL_WriteReg(HTS221_I2C_ADDRESS, RegAddr, NumByteToWrite, Data)\n\n\nHTS221_Error_et HTS221_WriteReg(uint8_t RegAddr, uint16_t NumByteToWrite, uint8_t* Data);\nHTS221_Error_et HTS221_ReadReg(uint8_t RegAddr, uint16_t NumByteToWrite, uint8_t* Data);\n\n\n// HTS221_Error_et HTS221_Get_DriverVersion(HTS221_DriverVersion_st* version);\nHTS221_Error_et HTS221_Get_DeviceID(uint8_t* deviceid);\n\nHTS221_Error_et HTS221_Set_InitConfig(HTS221_Init_st* pxInit);\nHTS221_Error_et HTS221_Get_InitConfig(HTS221_Init_st* pxInit);\nHTS221_Error_et HTS221_DeInit(void);\nHTS221_Error_et HTS221_IsMeasurementCompleted(HTS221_BitStatus_et* Is_Measurement_Completed);\n\nHTS221_Error_et HTS221_Get_Measurement(uint16_t* humidity, int16_t* temperature);\nHTS221_Error_et HTS221_Get_RawMeasurement(int16_t* humidity, int16_t* temperature);\nHTS221_Error_et HTS221_Get_Humidity(uint16_t* value);\nHTS221_Error_et HTS221_Get_HumidityRaw(int16_t* value);\nHTS221_Error_et HTS221_Get_TemperatureRaw(int16_t* value);\nHTS221_Error_et HTS221_Get_Temperature(int16_t* value);\nHTS221_Error_et HTS221_Get_DataStatus(HTS221_BitStatus_et* humidity, HTS221_BitStatus_et* temperature);\nHTS221_Error_et HTS221_Activate(void);\nHTS221_Error_et HTS221_DeActivate(void);\n\nHTS221_Error_et HTS221_Set_AvgHT(HTS221_Avgh_et avgh, HTS221_Avgt_et avgt);\nHTS221_Error_et HTS221_Set_AvgH(HTS221_Avgh_et avgh);\nHTS221_Error_et HTS221_Set_AvgT(HTS221_Avgt_et avgt);\nHTS221_Error_et HTS221_Get_AvgHT(HTS221_Avgh_et* avgh, HTS221_Avgt_et* avgt);\nHTS221_Error_et HTS221_Set_BduMode(HTS221_State_et status);\nHTS221_Error_et HTS221_Get_BduMode(HTS221_State_et* status);\nHTS221_Error_et HTS221_Set_PowerDownMode(HTS221_BitStatus_et status);\nHTS221_Error_et HTS221_Get_PowerDownMode(HTS221_BitStatus_et* status);\nHTS221_Error_et HTS221_Set_Odr(HTS221_Odr_et odr);\nHTS221_Error_et HTS221_Get_Odr(HTS221_Odr_et* odr);\nHTS221_Error_et HTS221_MemoryBoot(void);\nHTS221_Error_et HTS221_Set_HeaterState(HTS221_State_et status);\nHTS221_Error_et HTS221_Get_HeaterState(HTS221_State_et* status);\nHTS221_Error_et HTS221_StartOneShotMeasurement(void);\nHTS221_Error_et HTS221_Set_IrqActiveLevel(HTS221_DrdyLevel_et status);\nHTS221_Error_et HTS221_Get_IrqActiveLevel(HTS221_DrdyLevel_et* status);\nHTS221_Error_et HTS221_Set_IrqOutputType(HTS221_OutputType_et value);\nHTS221_Error_et HTS221_Get_IrqOutputType(HTS221_OutputType_et* value);\nHTS221_Error_et HTS221_Set_IrqEnable(HTS221_State_et status);\nHTS221_Error_et HTS221_Get_IrqEnable(HTS221_State_et* status);\n\n\nHTS221_Error_et HTS221_Setup(HTS221_Init_st* pxInit);\n\n#ifdef __cplusplus\n}\n#endif\n\n\n/**\n* @}\n*/\n\n/**\n* @}\n*/\n\n/**\n* @}\n*/\n\n#endif /* __HTS221_DRIVER__H */\n\n/******************* (C) COPYRIGHT 2013 STMicroelectronics *****END OF FILE****/\n"
            },
            "objects": {
                "hts221.c": "/**\n *\t----------------------------------------------------------------------------\n *\tCopyright (c) 2016, Anaren Microwave, Inc.\n *\n *\tFor more information on licensing, please see Anaren Microwave, Inc's\n *\tend user software licensing agreement: EULA.txt.\n *\n *\t----------------------------------------------------------------------------\n *\n *\thmc5883.c - driver interface for the Honeywell HMC5883L 3-Axis Digital\n *\tCompass.\n *\n *\t@version\t\t1.0.00\n *\t@date\t\t\t 14 Mar 2016\n *\t@author\t\t Anaren, air@anaren.com\n *\n *\tassumptions\n *\t===========\n *\t- The i2c driver provides the proper signaling sequences for read & write\n *\t\toperations.\n *\t- The i2c driver meets the timing requirements specified in the HMC5883L\n *\t\tdatasheet.\n *\n *\tfile dependency\n *\t===============\n *\ti2c.h : defines the i2c read & write interfaces.\n *\n *\trevision history\n *\t================\n *\tver 1.0.00 : 14 Mar 2016\n *\t- initial release\n */\n\n/* Includes ------------------------------------------------------------------*/\n#include \"hts221.h\"\n#ifdef  USE_FULL_ASSERT_HTS221\n#include <stdio.h>\n\n#endif\n\n\n\n/** @addtogroup Environmental_Sensor\n* @{\n*/\n\n/** @defgroup HTS221_DRIVER\n* @brief HTS221 DRIVER\n* @{\n*/\n\n\n/** @defgroup HTS221_Public_Functions\n* @{\n*/\n\n/**\n * @brief  Setup the Init struct with default values\n * @param  pxInit pointer to a HTS221_Init_st structure that contains the configuration.\n *         This parameter is a pointer to @ref HTS221_Init_st.\n * @retval Error code [HTS221_OK, HTS221_ERROR].\n */\nHTS221_Error_et HTS221_Setup(HTS221_Init_st* pxInit)\n{\n\tuint8_t htsDeviceID;\n\tHTS221_Get_DeviceID(&htsDeviceID); //verify device ID\n\n\tif(htsDeviceID != 0xBC)\n\t\treturn HTS221_ERROR;\n\n\tpxInit->avg_h = HTS221_AVGH_32; \t\t//samples to use; default 32\n\tpxInit->avg_t = HTS221_AVGT_16; \t\t//samples to use; default 16\n\tpxInit->bdu_status = HTS221_ENABLE; \t//HTS221_ENABLE: enable the block data update, output data registers are updated once both MSB and LSB are read.\n\tpxInit->heater_status = HTS221_DISABLE; //disable internal heater\n\tpxInit->irq_enable = HTS221_DISABLE; \t//disable irq\n\tpxInit->irq_level = HTS221_LOW_LVL;\n\tpxInit->irq_output_type = HTS221_PUSHPULL;\n\tpxInit->odr = HTS221_ODR_1HZ; \t\t\t//update temp/humidity @ 1hz\n\n\tHTS221_Set_InitConfig(pxInit);  \t\t//Write config to device\n\n\tHTS221_Set_PowerDownMode(HTS221_SET); \t//Turn on device\n\n\treturn HTS221_OK;\n}\n\n\n/**\n* @brief  Get the version of this driver.\n* @param  pxVersion pointer to a HTS221_DriverVersion_st structure that contains the version information.\n*         This parameter is a pointer to @ref HTS221_DriverVersion_st.\n* @retval Error code [HTS221_OK, HTS221_ERROR].\n*/\nHTS221_Error_et HTS221_Get_DriverVersion(HTS221_DriverVersion_st* version)\n{\n\tversion->Major = HTS221_DRIVER_VERSION_MAJOR;\n\tversion->Minor = HTS221_DRIVER_VERSION_MINOR;\n\tversion->Point = HTS221_DRIVER_VERSION_POINT;\n\n\treturn HTS221_OK;\n}\n\n/**\n* @brief  Get device type ID.\n* @param  deviceid pointer to the returned device type ID.\n* @retval Error code [HTS221_OK, HTS221_ERROR].\n*/\nHTS221_Error_et HTS221_Get_DeviceID(uint8_t* deviceid)\n{\n\tif(HTS221_ReadReg(HTS221_WHO_AM_I_REG, 1, deviceid))\n\t\treturn HTS221_ERROR;\n\n\treturn HTS221_OK;\n}\n\n/**\n * @brief  Initializes the HTS221 with the specified parameters in HTS221_Init_st struct.\n * @param  pxInit pointer to a HTS221_Init_st structure that contains the configuration.\n *         This parameter is a pointer to @ref HTS221_Init_st.\n * @retval Error code [HTS221_OK, HTS221_ERROR].\n */\nHTS221_Error_et HTS221_Set_InitConfig(HTS221_Init_st* pxInit)\n{\n\tuint8_t buffer[3];\n\n\tHTS221_assert_param(IS_HTS221_AVGH(pxInit->avg_h));\n\tHTS221_assert_param(IS_HTS221_AVGT(pxInit->avg_t));\n\tHTS221_assert_param(IS_HTS221_ODR(pxInit->odr));\n\tHTS221_assert_param(IS_HTS221_State(pxInit->bdu_status));\n\tHTS221_assert_param(IS_HTS221_State(pxInit->heater_status));\n\n\tHTS221_assert_param(IS_HTS221_DrdyLevelType(pxInit->irq_level));\n\tHTS221_assert_param(IS_HTS221_OutputType(pxInit->irq_output_type));\n\tHTS221_assert_param(IS_HTS221_State(pxInit->irq_enable));\n\n\tif(HTS221_ReadReg(HTS221_AV_CONF_REG, 1, buffer))\n\t\treturn HTS221_ERROR;\n\n\tbuffer[0] &= ~(HTS221_AVGH_MASK | HTS221_AVGT_MASK);\n\tbuffer[0] |= (uint8_t)pxInit->avg_h;\n\tbuffer[0] |= (uint8_t)pxInit->avg_t;\n\n\tif(HTS221_WriteReg(HTS221_AV_CONF_REG, 1, buffer))\n\t\treturn HTS221_ERROR;\n\n\tif(HTS221_ReadReg(HTS221_CTRL_REG1, 3, buffer))\n\t\treturn HTS221_ERROR;\n\n\tbuffer[0] &= ~(HTS221_BDU_MASK | HTS221_ODR_MASK);\n\tbuffer[0] |= (uint8_t)pxInit->odr;\n\tbuffer[0] |= ((uint8_t)pxInit->bdu_status)<<HTS221_BDU_BIT;\n\n\tbuffer[1] &= ~HTS221_HEATHER_BIT;\n\tbuffer[1] |= ((uint8_t)pxInit->heater_status)<<HTS221_HEATHER_BIT;\n\n\tbuffer[2] &= ~(HTS221_DRDY_H_L_MASK | HTS221_PP_OD_MASK | HTS221_DRDY_MASK);\n\tbuffer[2] |= ((uint8_t)pxInit->irq_level)<<HTS221_DRDY_H_L_BIT;\n\tbuffer[2] |= (uint8_t)pxInit->irq_output_type;\n\tbuffer[2] |= ((uint8_t)pxInit->irq_enable)<<HTS221_DRDY_BIT;\n\n\tif(HTS221_WriteReg(HTS221_CTRL_REG1, 3, buffer))\n\t\treturn HTS221_ERROR;\n\n\treturn HTS221_OK;\n}\n\n/**\n * @brief  Returns a HTS221_Init_st struct with the actual configuration.\n * @param  pxInit pointer to a HTS221_Init_st structure.\n *         This parameter is a pointer to @ref HTS221_Init_st.\n * @retval Error code [HTS221_OK, HTS221_ERROR].\n */\nHTS221_Error_et HTS221_Get_InitConfig(HTS221_Init_st* pxInit)\n{\n\tuint8_t buffer[3];\n\n\tif(HTS221_ReadReg(HTS221_AV_CONF_REG, 1, buffer))\n\t\treturn HTS221_ERROR;\n\n\tpxInit->avg_h = (HTS221_Avgh_et)(buffer[0] & HTS221_AVGH_MASK);\n\tpxInit->avg_t = (HTS221_Avgt_et)(buffer[0] & HTS221_AVGT_MASK);\n\n\tif(HTS221_ReadReg(HTS221_CTRL_REG1, 3, buffer))\n\t\treturn HTS221_ERROR;\n\n\tpxInit->odr = (HTS221_Odr_et)(buffer[0] & HTS221_ODR_MASK);\n\tpxInit->bdu_status = (HTS221_State_et)((buffer[0] & HTS221_BDU_MASK) >> HTS221_BDU_BIT);\n\tpxInit->heater_status = (HTS221_State_et)((buffer[1] & HTS221_HEATHER_MASK) >> HTS221_HEATHER_BIT);\n\n\tpxInit->irq_level = (HTS221_DrdyLevel_et)(buffer[2] & HTS221_DRDY_H_L_MASK);\n\tpxInit->irq_output_type = (HTS221_OutputType_et)(buffer[2] & HTS221_PP_OD_MASK);\n\tpxInit->irq_enable = (HTS221_State_et)((buffer[2] & HTS221_DRDY_MASK) >> HTS221_DRDY_BIT);\n\n\treturn HTS221_OK;\n}\n\n/**\n* @brief  De initialization function for HTS221.\n*         This function put the HTS221 in power down, make a memory boot and clear the data output flags.\n* @param  None.\n* @retval Error code [HTS221_OK, HTS221_ERROR].\n*/\nHTS221_Error_et HTS221_DeInit(void)\n{\n\tuint8_t buffer[4];\n\n\tif(HTS221_ReadReg(HTS221_CTRL_REG1, 2, buffer))\n\t\treturn HTS221_ERROR;\n\n\t/* HTS221 in power down */\n\tbuffer[0] |= 0x01<<HTS221_PD_BIT;\n\n\t/* Make HTS221 boot */\n\tbuffer[1] |= 0x01<<HTS221_BOOT_BIT;\n\n\tif(HTS221_WriteReg(HTS221_CTRL_REG1, 2, buffer))\n\t\treturn HTS221_ERROR;\n\n\t/* Dump of data output */\n\tif(HTS221_ReadReg(HTS221_HR_OUT_L_REG, 4, buffer))\n\t\treturn HTS221_ERROR;\n\n\treturn HTS221_OK;\n}\n\n/**\n* @brief  Read HTS221 output registers, and calculate humidity and temperature.\n* @param  humidity pointer to the returned humidity value that must be divided by 10 to get the value in [%].\n* @param  temperature pointer to the returned temperature value that must be divided by 10 to get the value in ['C].\n* @retval Error code [HTS221_OK, HTS221_ERROR].\n*/\nHTS221_Error_et HTS221_Get_Measurement(uint16_t* humidity, int16_t* temperature)\n{\n\tint16_t H0_T0_out, H1_T0_out, H_T_out;\n\tint16_t T0_out, T1_out, T_out, T0_degC_x8_u16, T1_degC_x8_u16;\n\tint16_t H0_rh, H1_rh;\n\tint16_t T0_degC, T1_degC;\n\tuint8_t buffer[8];\n\tint32_t tmp;\n\n\tif(HTS221_ReadReg(HTS221_HR_OUT_L_REG, 4, buffer))\n\t\treturn HTS221_ERROR;\n\n\tH_T_out = (((uint16_t)buffer[1])<<8) | (uint16_t)buffer[0];\n\tT_out = (((uint16_t)buffer[3])<<8) | (uint16_t)buffer[2];\n\n\tif(HTS221_ReadReg(HTS221_H0_RH_X2, 4, buffer))\n\t\treturn HTS221_ERROR;\n\n\tH0_rh = buffer[0]>>1;\n\tH1_rh = buffer[1]>>1;\n\n\tT0_degC_x8_u16 = (uint16_t)buffer[2];\n\tT1_degC_x8_u16 = (uint16_t)buffer[3];\n\n\tif(HTS221_ReadReg(HTS221_T0_T1_DEGC_H2, 3, buffer))\n\t\treturn HTS221_ERROR;\n\n\tT0_degC_x8_u16 |= (((uint16_t)(buffer[0] & 0x03)) << 8);\n\tT1_degC_x8_u16 |= (((uint16_t)(buffer[0] & 0x0C)) << 6);\n\tT0_degC = T0_degC_x8_u16>>3;\n\tT1_degC = T1_degC_x8_u16>>3;\n\n\tH0_T0_out = (((uint16_t)buffer[2])<<8) | (uint16_t)buffer[1];\n\n\tif(HTS221_ReadReg(HTS221_H1_T0_OUT_L, 6, buffer))\n\t\treturn HTS221_ERROR;\n\n\tH1_T0_out = (((uint16_t)buffer[1])<<8) | (uint16_t)buffer[0];\n\tT0_out = (((uint16_t)buffer[3])<<8) | (uint16_t)buffer[2];\n\tT1_out = (((uint16_t)buffer[5])<<8) | (uint16_t)buffer[4];\n\n\ttmp = ((uint32_t)(H_T_out - H0_T0_out)) * ((uint32_t)(H1_rh - H0_rh)*10);\n\t*humidity =    tmp/(H1_T0_out - H0_T0_out)  + H0_rh*10;\n\n\ttmp = ((int32_t)(T_out - T0_out)) * ((int32_t)(T1_degC - T0_degC)*10);\n\t*temperature = tmp /(T1_out - T0_out) + T0_degC*10;\n\n\tif(*humidity>1000) *humidity = 1000;\n\n\treturn HTS221_OK;\n}\n\n/**\n* @brief  Read HTS221 output registers. Humidity and temperature.\n* @param  humidity pointer to the returned humidity raw value.\n* @param  temperature pointer to the returned temperature raw value.\n* @retval Error code [HTS221_OK, HTS221_ERROR].\n*/\nHTS221_Error_et HTS221_Get_RawMeasurement(int16_t* humidity, int16_t* temperature)\n{\n\tuint8_t buffer[4];\n\n\tif(HTS221_ReadReg(HTS221_HR_OUT_L_REG, 4, buffer))\n\t\treturn HTS221_ERROR;\n\n\t*humidity = (int16_t)((((uint16_t)buffer[1])<<8) | (uint16_t)buffer[0]);\n\t*temperature = (int16_t)((((uint16_t)buffer[3])<<8) | (uint16_t)buffer[2]);\n\n\treturn HTS221_OK;\n}\n\n/**\n* @brief  Read HTS221 Humidity output registers, and calculate humidity.\n* @param  Pointer to the returned humidity value that must be divided by 10 to get the value in [%].\n* @retval Error code [HTS221_OK, HTS221_ERROR].\n*/\nHTS221_Error_et HTS221_Get_Humidity(uint16_t* value)\n{\n\tint16_t H0_T0_out, H1_T0_out, H_T_out;\n\tint16_t H0_rh, H1_rh;\n\tuint8_t buffer[2];\n\tint32_t tmp;\n\n\tif(HTS221_ReadReg(HTS221_H0_RH_X2, 2, buffer))\n\t\treturn HTS221_ERROR;\n\t\n\tH0_rh = buffer[0]>>1;\n\tH1_rh = buffer[1]>>1;\n\n\tif(HTS221_ReadReg(HTS221_H0_T0_OUT_L, 2, buffer))\n\t\treturn HTS221_ERROR;\n\t\n\tH0_T0_out = (((uint16_t)buffer[1])<<8) | (uint16_t)buffer[0];\n\n\tif(HTS221_ReadReg(HTS221_H1_T0_OUT_L, 2, buffer))\n\t\treturn HTS221_ERROR;\n\t\n\tH1_T0_out = (((uint16_t)buffer[1])<<8) | (uint16_t)buffer[0];\n\n\tif(HTS221_ReadReg(HTS221_HR_OUT_L_REG, 2, buffer))\n\t\treturn HTS221_ERROR;\n\t\n\tH_T_out = (((uint16_t)buffer[1])<<8) | (uint16_t)buffer[0];\n\n\ttmp = ((uint32_t)(H_T_out - H0_T0_out)) * ((uint32_t)(H1_rh - H0_rh)*10);\n\t*value =    tmp/(H1_T0_out - H0_T0_out)  + H0_rh*10;\n\n\tif(*value>1000) *value = 1000;\n\n\treturn HTS221_OK;\n}\n\n/**\n* @brief  Read HTS221 humidity output registers.\n* @param  Pointer to the returned humidity raw value.\n* @retval Error code [HTS221_OK, HTS221_ERROR].\n*/\nHTS221_Error_et HTS221_Get_HumidityRaw(int16_t* value)\n{\n\tuint8_t buffer[2];\n\n\tif(HTS221_ReadReg(HTS221_HR_OUT_L_REG, 2, buffer))\n\t\treturn HTS221_ERROR;\n\n\t*value = (int16_t)((((uint16_t)buffer[1])<<8) | (uint16_t)buffer[0]);\n\n\treturn HTS221_OK;\n}\n\n/**\n* @brief  Read HTS221 temperature output registers, and calculate temperature.\n* @param  Pointer to the returned temperature value that must be divided by 10 to get the value in ['C].\n* @retval Error code [HTS221_OK, HTS221_ERROR].\n*/\nHTS221_Error_et HTS221_Get_Temperature(int16_t *value)\n{\n\tint16_t T0_out, T1_out, T_out, T0_degC_x8_u16, T1_degC_x8_u16;\n\tint16_t T0_degC, T1_degC;\n\tuint8_t buffer[4], tmp;\n\tint32_t tmp32;\n\n\tif(HTS221_ReadReg(HTS221_T0_DEGC_X8, 2, buffer))\n\t\treturn HTS221_ERROR;\n\t\n\tif(HTS221_ReadReg(HTS221_T0_T1_DEGC_H2, 1, &tmp))\n\t\treturn HTS221_ERROR;\n\n\tT0_degC_x8_u16 = (((uint16_t)(tmp & 0x03)) << 8) | ((uint16_t)buffer[0]);\n\tT1_degC_x8_u16 = (((uint16_t)(tmp & 0x0C)) << 6) | ((uint16_t)buffer[1]);\n\tT0_degC = T0_degC_x8_u16>>3;\n\tT1_degC = T1_degC_x8_u16>>3;\n\n\tif(HTS221_ReadReg(HTS221_T0_OUT_L, 4, buffer))\n\t\treturn HTS221_ERROR;\n\n\tT0_out = (((uint16_t)buffer[1])<<8) | (uint16_t)buffer[0];\n\tT1_out = (((uint16_t)buffer[3])<<8) | (uint16_t)buffer[2];\n\n\tif(HTS221_ReadReg(HTS221_TEMP_OUT_L_REG, 2, buffer))\n\treturn HTS221_ERROR;\n\n\tT_out = (((uint16_t)buffer[1])<<8) | (uint16_t)buffer[0];\n\n\ttmp32 = ((uint32_t)(T_out - T0_out)) * ((uint32_t)(T1_degC - T0_degC)*10);\n\t*value = tmp32 /(T1_out - T0_out)  + T0_degC*10;\n\n\treturn HTS221_OK;\n}\n\n/**\n* @brief  Read HTS221 temperature output registers.\n* @param  Pointer to the returned temperature raw value.\n* @retval Error code [HTS221_OK, HTS221_ERROR].\n*/\nHTS221_Error_et HTS221_Get_TemperatureRaw(int16_t* value)\n{\n\tuint8_t buffer[2];\n\n\tif(HTS221_ReadReg(HTS221_TEMP_OUT_L_REG, 2, buffer))\n\t\treturn HTS221_ERROR;\n\n\t*value = (int16_t)((((uint16_t)buffer[1])<<8) | (uint16_t)buffer[0]);\n\n\treturn HTS221_OK;\n}\n\n/**\n* @brief  Get the availability of new data for humidity and temperature.\n* @param  humidity pointer to the returned humidity data status [HTS221_SET/HTS221_RESET].\n* @param  temperature pointer to the returned temperature data status [HTS221_SET/HTS221_RESET].\n*         This parameter is a pointer to @ref HTS221_BitStatus_et.\n* @retval Error code [HTS221_OK, HTS221_ERROR].\n*/\nHTS221_Error_et HTS221_Get_DataStatus(HTS221_BitStatus_et* humidity, HTS221_BitStatus_et* temperature)\n{\n\tuint8_t tmp;\n\n\tif(HTS221_ReadReg(HTS221_STATUS_REG, 1, &tmp))\n\t\treturn HTS221_ERROR;\n\n\t*humidity = (HTS221_BitStatus_et)((tmp & HTS221_HDA_MASK)>>HTS221_H_DA_BIT);\n\t*temperature = (HTS221_BitStatus_et)(tmp & HTS221_TDA_MASK);\n\n\treturn HTS221_OK;\n}\n\n/**\n* @brief  Exit from power down mode.\n* @param  void.\n* @retval Error code [HTS221_OK, HTS221_ERROR].\n*/\nHTS221_Error_et HTS221_Activate(void)\n{\n\tuint8_t tmp;\n\n\tif(HTS221_ReadReg(HTS221_CTRL_REG1, 1, &tmp))\n\t\treturn HTS221_ERROR;\n\n\ttmp &= ~HTS221_PD_MASK;\n\n\tif(HTS221_WriteReg(HTS221_CTRL_REG1, 1, &tmp))\n\t\treturn HTS221_ERROR;\n\n\treturn HTS221_OK;\n}\n\n/**\n* @brief  Put the sensor in power down mode.\n* @param  void.\n* @retval Error code [HTS221_OK, HTS221_ERROR].\n*/\nHTS221_Error_et HTS221_DeActivate(void)\n{\n\tuint8_t tmp;\n\n\tif(HTS221_ReadReg(HTS221_CTRL_REG1, 1, &tmp))\n\t\treturn HTS221_ERROR;\n\n\ttmp |= HTS221_PD_MASK;\n\n\tif(HTS221_WriteReg(HTS221_CTRL_REG1, 1, &tmp))\n\t\treturn HTS221_ERROR;\n\n\treturn HTS221_OK;\n}\n\n\n\n/**\n  * @brief  Check if the single measurement has completed.\n* @param  tmp is set to 1, when the measure is completed\n  * @retval Status [LPS25H_ERROR, LPS25H_OK]\n*/\nHTS221_Error_et HTS221_IsMeasurementCompleted(HTS221_BitStatus_et* Is_Measurement_Completed)\n{\n\tuint8_t tmp;\n\n\tif(HTS221_ReadReg(HTS221_STATUS_REG, 1, &tmp))\n\t\t\treturn HTS221_ERROR;\n\n\tif((tmp & (uint8_t)(HTS221_HDA_MASK | HTS221_TDA_MASK)) == (uint8_t)(HTS221_HDA_MASK | HTS221_TDA_MASK))\n\t\t*Is_Measurement_Completed = HTS221_SET;\n\telse\n\t\t*Is_Measurement_Completed = HTS221_RESET;\n\n\treturn HTS221_OK;\n }\n\n\n/**\n* @brief  Set_ humidity and temperature average mode.\n* @param  avgh is the average mode for humidity, this parameter is @ref HTS221_Avgh_et.\n* @param  avgt is the average mode for temperature, this parameter is @ref HTS221_Avgt_et.\n* @retval Error code [HTS221_OK, HTS221_ERROR].\n*/\nHTS221_Error_et HTS221_Set_AvgHT(HTS221_Avgh_et avgh, HTS221_Avgt_et avgt)\n{\n\tuint8_t tmp;\n\n\tHTS221_assert_param(IS_HTS221_AVGH(avgh));\n\tHTS221_assert_param(IS_HTS221_AVGT(avgt));\n\n\tif(HTS221_ReadReg(HTS221_AV_CONF_REG, 1, &tmp))\n\t\treturn HTS221_ERROR;\n\n\ttmp &= ~(HTS221_AVGH_MASK | HTS221_AVGT_MASK);\n\ttmp |= (uint8_t)avgh;\n\ttmp |= (uint8_t)avgt;\n\n\tif(HTS221_WriteReg(HTS221_AV_CONF_REG, 1, &tmp))\n\t\treturn HTS221_ERROR;\n\n\treturn HTS221_OK;\n}\n\n/**\n* @brief  Set humidity average mode.\n* @param  avgh is the average mode for humidity, this parameter is @ref HTS221_Avgh_et.\n* @retval Error code [HTS221_OK, HTS221_ERROR].\n*/\nHTS221_Error_et HTS221_Set_AvgH(HTS221_Avgh_et avgh)\n{\n\tuint8_t tmp;\n\n\tHTS221_assert_param(IS_HTS221_AVGH(avgh));\n\n\tif(HTS221_ReadReg(HTS221_AV_CONF_REG, 1, &tmp))\n\t\treturn HTS221_ERROR;\n\n\ttmp &= ~HTS221_AVGH_MASK;\n\ttmp |= (uint8_t)avgh;\n\n\tif(HTS221_WriteReg(HTS221_AV_CONF_REG, 1, &tmp))\n\t\treturn HTS221_ERROR;\n\n\treturn HTS221_OK;\n}\n\n/**\n* @brief  Set temperature average mode.\n* @param  avgt is the average mode for temperature, this parameter is @ref HTS221_Avgt_et.\n* @retval Error code [HTS221_OK, HTS221_ERROR].\n*/\nHTS221_Error_et HTS221_Set_AvgT(HTS221_Avgt_et avgt)\n{\n\tuint8_t tmp;\n\n\tHTS221_assert_param(IS_HTS221_AVGT(avgt));\n\n\tif(HTS221_ReadReg(HTS221_AV_CONF_REG, 1, &tmp))\n\t\treturn HTS221_ERROR;\n\n\ttmp &= ~HTS221_AVGT_MASK;\n\ttmp |= (uint8_t)avgt;\n\n\tif(HTS221_WriteReg(HTS221_AV_CONF_REG, 1, &tmp))\n\t\treturn HTS221_ERROR;\n\n\treturn HTS221_OK;\n}\n\n/**\n* @brief  Get humidity and temperature average mode.\n* @param  avgh pointer to the returned value with the humidity average mode.\n* @param  avgt pointer to the returned value with the temperature average mode.\n* @retval Error code [HTS221_OK, HTS221_ERROR].\n*/\nHTS221_Error_et HTS221_Get_AvgHT(HTS221_Avgh_et* avgh, HTS221_Avgt_et* avgt)\n{\n\tuint8_t tmp;\n\n\tif(HTS221_ReadReg(HTS221_AV_CONF_REG, 1, &tmp))\n\t\treturn HTS221_ERROR;\n\n\t*avgh = (HTS221_Avgh_et)(tmp & HTS221_AVGH_MASK);\n\t*avgt = (HTS221_Avgt_et)(tmp & HTS221_AVGT_MASK);\n\n\treturn HTS221_OK;\n}\n\n/**\n* @brief  Set block data update mode.\n* @param  status can be HTS221_ENABLE: enable the block data update, output data registers are updated once both MSB and LSB are read.\n* @param  status can be HTS221_DISABLE: output data registers are continuously updated.\n*         This parameter is a @ref HTS221_BitStatus_et.\n* @retval Error code [HTS221_OK, HTS221_ERROR].\n*/\nHTS221_Error_et HTS221_Set_BduMode(HTS221_State_et status)\n{\n\tuint8_t tmp;\n\n\tHTS221_assert_param(IS_HTS221_State(status));\n\n\tif(HTS221_ReadReg(HTS221_CTRL_REG1, 1, &tmp))\n\t\treturn HTS221_ERROR;\n\n\ttmp &= ~HTS221_BDU_MASK;\n\ttmp |= ((uint8_t)status)<<HTS221_BDU_BIT;\n\n\tif(HTS221_WriteReg(HTS221_CTRL_REG1, 1, &tmp))\n\t\treturn HTS221_ERROR;\n\n\treturn HTS221_OK;\n}\n\n/**\n* @brief  Get block data update mode.\n* @param  Pointer to the returned value with block data update mode status.\n* @retval Error code [HTS221_OK, HTS221_ERROR].\n*/\nHTS221_Error_et HTS221_Get_BduMode(HTS221_State_et* status)\n{\n\tuint8_t tmp;\n\n\tif(HTS221_ReadReg(HTS221_CTRL_REG1, 1, &tmp))\n\t\treturn HTS221_ERROR;\n\n\t*status = (HTS221_State_et)((tmp & HTS221_BDU_MASK) >> HTS221_BDU_BIT);\n\n\treturn HTS221_OK;\n}\n\n/**\n* @brief  Enter or exit from power down mode.\n* @param  status can be HTS221_SET: HTS221 in power down mode.\n* @param  status can be HTS221_REET: HTS221 in active mode.\n*         This parameter is a @ref HTS221_BitStatus_et.\n* @retval Error code [HTS221_OK, HTS221_ERROR].\n*/\nHTS221_Error_et HTS221_Set_PowerDownMode(HTS221_BitStatus_et status)\n{\n\tuint8_t tmp;\n\n\tHTS221_assert_param(IS_HTS221_BitStatus(status));\n\n\tif(HTS221_ReadReg(HTS221_CTRL_REG1, 1, &tmp))\n\t\treturn HTS221_ERROR;\n\n\ttmp &= ~HTS221_PD_MASK;\n\ttmp |= ((uint8_t)status)<<HTS221_PD_BIT;\n\n\tif(HTS221_WriteReg(HTS221_CTRL_REG1, 1, &tmp))\n\t\treturn HTS221_ERROR;\n\n\treturn HTS221_OK;\n}\n\n/**\n* @brief  Get if HTS221 is in active mode or in power down mode.\n* @param  Pointer to the returned value with HTS221 status.\n* @retval Error code [HTS221_OK, HTS221_ERROR].\n*/\nHTS221_Error_et HTS221_Get_PowerDownMode(HTS221_BitStatus_et* status)\n{\n\tuint8_t tmp;\n\n\tif(HTS221_ReadReg(HTS221_CTRL_REG1, 1, &tmp))\n\t\treturn HTS221_ERROR;\n\n\t*status = (HTS221_BitStatus_et)((tmp & HTS221_PD_MASK) >> HTS221_PD_BIT);\n\n\treturn HTS221_OK;\n}\n\n/**\n* @brief  Set the output data rate mode.\n* @param  odr is the output data rate mode.\n*         This parameter is a @ref HTS221_Odr_et.\n* @retval Error code [HTS221_OK, HTS221_ERROR].\n*/\nHTS221_Error_et HTS221_Set_Odr(HTS221_Odr_et odr)\n{\n\tuint8_t tmp;\n\n\tHTS221_assert_param(IS_HTS221_ODR(odr));\n\n\tif(HTS221_ReadReg(HTS221_CTRL_REG1, 1, &tmp))\n\t\treturn HTS221_ERROR;\n\n\ttmp &= ~HTS221_ODR_MASK;\n\ttmp |= (uint8_t)odr;\n\n\tif(HTS221_WriteReg(HTS221_CTRL_REG1, 1, &tmp))\n\t\treturn HTS221_ERROR;\n\n\treturn HTS221_OK;\n}\n\n/**\n* @brief  Get the output data rate mode.\n* @param  Pointer to the returned value with output data rate mode.\n* @retval Error code [HTS221_OK, HTS221_ERROR].\n*/\nHTS221_Error_et HTS221_Get_Odr(HTS221_Odr_et* odr)\n{\n\tuint8_t tmp;\n\n\tif(HTS221_ReadReg(HTS221_CTRL_REG1, 1, &tmp))\n\t\treturn HTS221_ERROR;\n\n\ttmp &= HTS221_ODR_MASK;\n\t*odr = (HTS221_Odr_et)tmp;\n\n\treturn HTS221_OK;\n}\n\n/**\n* @brief  Reboot Memory Content.\n* @param  None.\n* @retval Error code [HTS221_OK, HTS221_ERROR].\n*/\nHTS221_Error_et HTS221_MemoryBoot(void)\n{\n\tuint8_t tmp;\n\n\tif(HTS221_ReadReg(HTS221_CTRL_REG2, 1, &tmp))\n\t\treturn HTS221_ERROR;\n\n\ttmp |= HTS221_BOOT_MASK;\n\n\tif(HTS221_WriteReg(HTS221_CTRL_REG2, 1, &tmp))\n\t\treturn HTS221_ERROR;\n\n\treturn HTS221_OK;\n}\n\n/**\n* @brief  Configure the internal heater.\n* @param  The status of the internal heater [HTS221_ENABLE/HTS221_DISABLE].\n*         This parameter is a @ref HTS221_State_et.\n* @retval Error code [HTS221_OK, HTS221_ERROR]\n*/\nHTS221_Error_et HTS221_Set_HeaterState(HTS221_State_et status)\n{\n\tuint8_t tmp;\n\n\tHTS221_assert_param(IS_HTS221_State(status));\n\n\tif(HTS221_ReadReg(HTS221_CTRL_REG2, 1, &tmp))\n\t\treturn HTS221_ERROR;\n\n\ttmp &= ~HTS221_HEATHER_MASK;\n\ttmp |= ((uint8_t)status)<<HTS221_HEATHER_BIT;\n\n\tif(HTS221_WriteReg(HTS221_CTRL_REG2, 1, &tmp))\n\t\treturn HTS221_ERROR;\n\n\treturn HTS221_OK;\n}\n\n/**\n* @brief  Get the internal heater.\n* @param  Pointer to the returned status of the internal heater [HTS221_ENABLE/HTS221_DISABLE].\n* @retval Error code [HTS221_OK, HTS221_ERROR].\n*/\nHTS221_Error_et HTS221_Get_HeaterState(HTS221_State_et* status)\n{\n\tuint8_t tmp;\n\n\tif(HTS221_ReadReg(HTS221_CTRL_REG2, 1, &tmp))\n\t\treturn HTS221_ERROR;\n\n\t*status = (HTS221_State_et)((tmp & HTS221_HEATHER_MASK) >> HTS221_HEATHER_BIT);\n\n\treturn HTS221_OK;\n}\n\n/**\n* @brief  Set ONE_SHOT bit to start a new conversion (ODR mode has to be 00).\n*         Once the measurement is done, ONE_SHOT bit is self-cleared.\n* @param  None.\n* @retval Error code [HTS221_OK, HTS221_ERROR].\n*/\nHTS221_Error_et HTS221_StartOneShotMeasurement(void)\n{\n\tuint8_t tmp;\n\n\tif(HTS221_ReadReg(HTS221_CTRL_REG2, 1, &tmp))\n\t\treturn HTS221_ERROR;\n\n\ttmp |= HTS221_ONE_SHOT_MASK;\n\n\tif(HTS221_WriteReg(HTS221_CTRL_REG2, 1, &tmp))\n\t\treturn HTS221_ERROR;\n\n\treturn HTS221_OK;\n\n}\n\n/**\n* @brief  Set level configuration of the interrupt pin DRDY.\n* @param  status can be HTS221_LOW_LVL: active level is LOW.\n* @param  status can be HTS221_HIGH_LVL: active level is HIGH.\n*         This parameter is a @ref HTS221_State_et.\n* @retval Error code [HTS221_OK, HTS221_ERROR].\n*/\nHTS221_Error_et HTS221_Set_IrqActiveLevel(HTS221_DrdyLevel_et value)\n{\n\tuint8_t tmp;\n\n\tHTS221_assert_param(IS_HTS221_DrdyLevelType(value));\n\n\tif(HTS221_ReadReg(HTS221_CTRL_REG3, 1, &tmp))\n\t\treturn HTS221_ERROR;\n\n\ttmp &= ~HTS221_DRDY_H_L_MASK;\n\ttmp |= (uint8_t)value;\n\n\tif(HTS221_WriteReg(HTS221_CTRL_REG3, 1, &tmp))\n\t\treturn HTS221_ERROR;\n\n\treturn HTS221_OK;\n}\n\n/**\n* @brief  Get level configuration of the interrupt pin DRDY.\n* @param  Pointer to the returned status of the level configuration [HTS221_ENABLE/HTS221_DISABLE].\n* @retval Error code [HTS221_OK, HTS221_ERROR].\n*/\nHTS221_Error_et HTS221_Get_IrqActiveLevel(HTS221_DrdyLevel_et* value)\n{\n\tuint8_t tmp;\n\n\tif(HTS221_ReadReg(HTS221_CTRL_REG3, 1, &tmp))\n\t\treturn HTS221_ERROR;\n\n\t*value = (HTS221_DrdyLevel_et)(tmp & HTS221_DRDY_H_L_MASK);\n\n\treturn HTS221_OK;\n}\n\n/**\n* @brief  Set Push-pull/open drain configuration for the interrupt pin DRDY.\n* @param  value is the output type configuration.\n*         This parameter is a @ref HTS221_OutputType_et.\n* @retval Error code [HTS221_OK, HTS221_ERROR].\n*/\nHTS221_Error_et HTS221_Set_IrqOutputType(HTS221_OutputType_et value)\n{\n\tuint8_t tmp;\n\n\tHTS221_assert_param(IS_HTS221_OutputType(value));\n\n\tif(HTS221_ReadReg(HTS221_CTRL_REG3, 1, &tmp))\n\t\treturn HTS221_ERROR;\n\n\ttmp &= ~HTS221_PP_OD_MASK;\n\ttmp |= (uint8_t)value;\n\n\tif(HTS221_WriteReg(HTS221_CTRL_REG3, 1, &tmp))\n\t\treturn HTS221_ERROR;\n\n\treturn HTS221_OK;\n}\n\n/**\n* @brief  Get the configuration for the interrupt pin DRDY.\n* @param  Pointer to the returned value with output type configuration.\n* @retval Error code [HTS221_OK, HTS221_ERROR].\n*/\nHTS221_Error_et HTS221_Get_IrqOutputType(HTS221_OutputType_et* value)\n{\n\tuint8_t tmp;\n\n\tif(HTS221_ReadReg(HTS221_CTRL_REG3, 1, &tmp))\n\t\treturn HTS221_ERROR;\n\n\t*value = (HTS221_OutputType_et)(tmp & HTS221_PP_OD_MASK);\n\n\treturn HTS221_OK;\n}\n\n/**\n* @brief  Enable/disable the interrupt mode.\n* @param  status is the enable/disable for the interrupt mode.\n*         This parameter is a @ref HTS221_State_et.\n* @retval Error code [HTS221_OK, HTS221_ERROR].\n*/\nHTS221_Error_et HTS221_Set_IrqEnable(HTS221_State_et status)\n{\n\tuint8_t tmp;\n\n\tHTS221_assert_param(IS_HTS221_State(status));\n\n\tif(HTS221_ReadReg(HTS221_CTRL_REG3, 1, &tmp))\n\t\treturn HTS221_ERROR;\n\n\ttmp &= ~HTS221_DRDY_MASK;\n\ttmp |= ((uint8_t)status)<<HTS221_DRDY_BIT;\n\n\tif(HTS221_WriteReg(HTS221_CTRL_REG3, 1, &tmp))\n\t\treturn HTS221_ERROR;\n\n\treturn HTS221_OK;\n}\n\n/**\n* @brief  Get the interrupt mode.\n* @param  Pointer to the returned status of the interrupt mode configuration [HTS221_ENABLE/HTS221_DISABLE].\n* @retval Error code [HTS221_OK, HTS221_ERROR].\n*/\nHTS221_Error_et HTS221_Get_IrqEnable(HTS221_State_et* status)\n{\n\tuint8_t tmp;\n\n\tif(HTS221_ReadReg(HTS221_CTRL_REG3, 1, &tmp))\n\t\treturn HTS221_ERROR;\n\n\t*status = (HTS221_State_et)((tmp & HTS221_DRDY_MASK) >> HTS221_DRDY_BIT);\n\n\treturn HTS221_OK;\n}\n\n\n#ifdef  USE_FULL_ASSERT_HTS221\n/**\n* @brief  Reports the name of the source file and the source line number\n*         where the assert_param error has occurred.\n* @param file: pointer to the source file name\n* @param line: assert_param error line source number\n* @retval : None\n*/\nvoid HTS221_assert_failed(uint8_t* file, uint32_t line)\n{\n\t/* User can add his own implementation to report the file name and line number */\n\tprintf(\"Wrong parameters value: file %s on line %lu\\r\\n\", file, (unsigned long)line);\n\n\t/* Infinite loop */\n\twhile (1)\n\t{\n\t}\n}\n#endif\n\n/**\n* @brief  Writes data to register in hts221\n*\n* @param RegAddr: register address in hts221\n* @param NumByteToWrite: specify how many bytes of Data to write\n* @param Data: pointer to Data that needs to be written\n* @retval Error code [HTS221_OK, HTS221_ERROR].\n*/\nHTS221_Error_et HTS221_WriteReg(uint8_t RegAddr, uint16_t NumByteToWrite, uint8_t* Data) {\n\n\tuint8_t writeBytes[2];\n\tuint8_t counter;\n\t\n\tfor(counter = 0; counter < NumByteToWrite; counter++) { //Loop through for each byte\n\n\t\twriteBytes[0] = RegAddr+counter;\n\t\twriteBytes[1] = Data[counter];\n\n\t\tAIR_I2C_Write(HTS221_I2C_ADDRESS>>1,writeBytes,2);\n\t}\n\n\treturn HTS221_OK;\n}\n\n/**\n* @brief  Read data from hts221\n*\n* @param RegAddr: register address in hts221\n* @param NumByteToRead: specify how many bytes of Data to read\n* @param Data: pointer to Data location to read to\n* @retval Error code [HTS221_OK, HTS221_ERROR].\n*/\nHTS221_Error_et HTS221_ReadReg(uint8_t RegAddr, uint16_t NumByteToRead, uint8_t* Data) {\n\tuint8_t writeBytes[1];\n\tuint8_t counter;\n\t\n\tfor(counter = 0; counter < NumByteToRead; counter++) { //Loop through for each byte\n\t\twriteBytes[0] = RegAddr+counter;\n\t\tAIR_I2C_ComboRead(HTS221_I2C_ADDRESS>>1, writeBytes, 1, Data+(counter*sizeof(uint8_t)), 1);\n\t}\n\n\treturn HTS221_OK;\n}\n\n/**\n* @}\n*/\n\n/**\n* @}\n*/\n\n/**\n* @}\n*/\n\n/******************* (C) COPYRIGHT 2013 STMicroelectronics *****END OF FILE****/\n"
            },
            "other": {}
        }
    },
    "label": "HTS221 Driver",
    "language": {
        "en": {
            "label": "HTS221 Driver"
        }
    },
    "links": {
        "Datasheet": "http://www.st.com/st-web-ui/static/active/en/resource/technical/document/datasheet/DM00116291.pdf",
        "Product Page": "http://www.st.com/web/en/catalog/sense_power/FM89/SC1718/PF260067",
        "Wiki Page": "https://atmosphere.anaren.com/wiki/HTS221_Driver"
    },
    "manufacturer": "STMicroelectronics",
    "name": "hts221",
    "signature": "",
    "type": "Embedded Library",
    "version": "1.0.0"
}