{
    "author": "STMicroelectronics, Anaren Inc.",
    "categories": [
        "New",
        "Humidity",
        "Temperature",
        "Sensor"
    ],
    "code": {
        "connected": " \r\n",
        "global": "",
        "interval": " \r\n",
        "setup": "\t//HTS221 Init structure definition\n\tHTS221_Init_st hts221Init;\n\t//Init HTS221 \n\tHTS221_Setup(&hts221Init);"
    },
    "config": {
        "file": "hts221_config.h",
        "values": {
            "i2c_address": {
                "input": "Combo",
                "name": "I2C Address (7 bit)",
                "options": [
                    "0xbe",
                    "0xbd"
                ],
                "prefix": "#define AIR_HTS221_I2C_ADDRESS ",
                "regex": "^[a-zA-Z0-9_.]*$",
                "value": "0xbe"
            }
        }
    },
    "description": "The HTS221 is an ultra compact sensor for relative humidity and temperature. It includes a sensing element and a mixed signal ASIC to provide the measurement information through digital serial interfaces.",
    "elements": {
        "humidity": {
            "code": "\tint16_t htsHumid;\n\n\t/**\n\tRead the relative humidity.  When set to Continuous Conversion mode, the\n\tdevice periodically performs humidity conversions at a predefined rate.  This\n\tfunction calulates the humidity using only the most recent conversion value.\n\t@param htsHumid int16_t to hold calculated humidity\n\t@param htsTemp uint16_t to hold calculated temperature\n\t@return htsHumid returns humidity value that must be divided by 10 to get the value in [%].\n\t*/\n\n\tHTS221_Get_Humidity(&htsHumid);\n\n\treturn htsHumid / 10.0f; \n",
            "icon": "data:image/png;base64,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\nAAAAAElFTkSuQmCC\n",
            "inputType": "void",
            "label": "Humidity",
            "language": {
                "en": {
                    "label": "Humidity"
                }
            },
            "returnType": "float"
        },
        "temperature": {
            "code": "\tint16_t htsTemp;\n\n\t/**\n\tRead the temperature.  When set to Continuous Conversion mode, the\n\tdevice periodically performs temperature conversions at a predefined rate.  This\n\tfunction calulates the temperature using only the most recent conversion value.\n\t@param htsHumid int16_t to hold calculated humidity\n\t@return htsTemp temperature value that must be divided by 10 to get the value in ['C]\n\t*/\n\n\tHTS221_Get_Temperature(&htsTemp);\n\n\treturn htsTemp / 10.0f; \n",
            "icon": "data:image/png;base64,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\nEfHb7/8PB5afK/zavVwAAAAASUVORK5CYII=\n",
            "inputType": "void",
            "label": "Temperature",
            "language": {
                "en": {
                    "label": "Temperature"
                }
            },
            "returnType": "float"
        }
    },
    "files": {
        "common": {
            "headers": {
                "hts221.h": "/**\n******************************************************************************\n* @file    HTS221_Driver.h\n* @author  HESA Application Team\n* @version 1.0.0\n* @date    07/04/2014\n* @brief   HTS221 driver header file\n\n* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS\n* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE\n* TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY\n* DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING\n* FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE\n* CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.\n*\n* THIS SOURCE CODE IS PROTECTED BY A LICENSE.\n* FOR MORE INFORMATION PLEASE CAREFULLY READ THE LICENSE AGREEMENT FILE LOCATED\n* IN THE ROOT DIRECTORY OF THIS FIRMWARE PACKAGE.\n*\n* <h2><center>&copy; COPYRIGHT 2013 STMicroelectronics</center></h2>\n\n******************************************************************************\n*/\n\n/* Define to prevent recursive inclusion -------------------------------------*/\n#ifndef __HTS221_DRIVER__H\n#define __HTS221_DRIVER__H\n\n#include \"../i2c/i2c.h\"\n#include \"hts221_config.h\"\n#include <stdint.h>\n\n/* Uncomment the line below to expanse the \"assert_param\" macro in the drivers code */\n// #define USE_FULL_ASSERT_HTS221\n\n/* Exported macro ------------------------------------------------------------*/\n#ifdef  USE_FULL_ASSERT_HTS221\n\n/**\n* @brief  The assert_param macro is used for function's parameters check.\n* @param  expr: If expr is false, it calls assert_failed function which reports\n*         the name of the source file and the source line number of the call\n*         that failed. If expr is true, it returns no value.\n* @retval None\n*/\n#define HTS221_assert_param(expr) ((expr) ? (void)0 : HTS221_assert_failed((uint8_t *)__FILE__, __LINE__))\n/* Exported functions ------------------------------------------------------- */\nvoid HTS221_assert_failed(uint8_t* file, uint32_t line);\n#else\n#define HTS221_assert_param(expr) ((void)0)\n#endif /* USE_FULL_ASSERT_HTS221 */\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/** @addtogroup Environmental_Sensor\n* @{\n*/\n\n/** @addtogroup HTS221_DRIVER\n* @{\n*/\n\n/* Exported Types -------------------------------------------------------------*/\n/** @defgroup HTS221_Exported_Types\n* @{\n*/\n\n\n/**\n* @brief  Error code type.\n*/\ntypedef enum {HTS221_OK = (uint8_t)0, HTS221_ERROR = !HTS221_OK} HTS221_Error_et;\n\n/**\n* @brief  State type.\n*/\ntypedef enum {HTS221_DISABLE = (uint8_t)0, HTS221_ENABLE = !HTS221_DISABLE} HTS221_State_et;\n#define IS_HTS221_State(MODE) ((MODE == HTS221_ENABLE) || (MODE == HTS221_DISABLE))\n\n/**\n* @brief  Bit status type.\n*/\ntypedef enum {HTS221_RESET = (uint8_t)0, HTS221_SET = !HTS221_RESET} HTS221_BitStatus_et;\n#define IS_HTS221_BitStatus(MODE) ((MODE == HTS221_RESET) || (MODE == HTS221_SET))\n\n/**\n* @brief  Humidity average.\n*/\ntypedef enum {\n  HTS221_AVGH_4         = (uint8_t)0x00,         /*!< Internal average on 4 samples */\n  HTS221_AVGH_8         = (uint8_t)0x01,         /*!< Internal average on 8 samples */\n  HTS221_AVGH_16        = (uint8_t)0x02,         /*!< Internal average on 16 samples */\n  HTS221_AVGH_32        = (uint8_t)0x03,         /*!< Internal average on 32 samples */\n  HTS221_AVGH_64        = (uint8_t)0x04,         /*!< Internal average on 64 samples */\n  HTS221_AVGH_128       = (uint8_t)0x05,         /*!< Internal average on 128 samples */\n  HTS221_AVGH_256       = (uint8_t)0x06,         /*!< Internal average on 256 samples */\n  HTS221_AVGH_512       = (uint8_t)0x07          /*!< Internal average on 512 samples */\n}HTS221_Avgh_et;\n#define IS_HTS221_AVGH(AVGH) ((AVGH == HTS221_AVGH_4) || (AVGH == HTS221_AVGH_8) || \\\n                              (AVGH == HTS221_AVGH_16) || (AVGH == HTS221_AVGH_32) || \\\n                              (AVGH == HTS221_AVGH_64) || (AVGH == HTS221_AVGH_128) || \\\n                              (AVGH == HTS221_AVGH_256) || (AVGH == HTS221_AVGH_512))\n\n/**\n* @brief  Temperature average.\n*/\ntypedef enum {\n  HTS221_AVGT_2         = (uint8_t)0x00,        /*!< Internal average on 2 samples */\n  HTS221_AVGT_4         = (uint8_t)0x08,        /*!< Internal average on 4 samples */\n  HTS221_AVGT_8         = (uint8_t)0x10,        /*!< Internal average on 8 samples */\n  HTS221_AVGT_16        = (uint8_t)0x18,        /*!< Internal average on 16 samples */\n  HTS221_AVGT_32        = (uint8_t)0x20,        /*!< Internal average on 32 samples */\n  HTS221_AVGT_64        = (uint8_t)0x28,        /*!< Internal average on 64 samples */\n  HTS221_AVGT_128       = (uint8_t)0x30,        /*!< Internal average on 128 samples */\n  HTS221_AVGT_256       = (uint8_t)0x38         /*!< Internal average on 256 samples */\n}HTS221_Avgt_et;\n#define IS_HTS221_AVGT(AVGT) ((AVGT == HTS221_AVGT_2) || (AVGT == HTS221_AVGT_4) || \\\n                              (AVGT == HTS221_AVGT_8) || (AVGT == HTS221_AVGT_16) || \\\n                              (AVGT == HTS221_AVGT_32) || (AVGT == HTS221_AVGT_64) || \\\n                              (AVGT == HTS221_AVGT_128) || (AVGT == HTS221_AVGT_256))\n\n/**\n* @brief  Output data rate configuration.\n*/\ntypedef enum {\n  HTS221_ODR_ONE_SHOT  = (uint8_t)0x00,         /*!< Output Data Rate: one shot */\n  HTS221_ODR_1HZ       = (uint8_t)0x01,         /*!< Output Data Rate: 1Hz */\n  HTS221_ODR_7HZ       = (uint8_t)0x02,         /*!< Output Data Rate: 7Hz */\n  HTS221_ODR_12_5HZ    = (uint8_t)0x03,         /*!< Output Data Rate: 12.5Hz */\n} HTS221_Odr_et;\n#define IS_HTS221_ODR(ODR) ((ODR == HTS221_ODR_ONE_SHOT) || (ODR == HTS221_ODR_1HZ) || \\\n                            (ODR == HTS221_ODR_7HZ) || (ODR == HTS221_ODR_12_5HZ))\n\n\n/**\n* @brief  Push-pull/Open Drain selection on DRDY pin.\n*/\ntypedef enum {\n  HTS221_PUSHPULL   = (uint8_t)0x00,   /*!< DRDY pin in push pull */\n  HTS221_OPENDRAIN  = (uint8_t)0x40    /*!< DRDY pin in open drain */\n}HTS221_OutputType_et;\n#define IS_HTS221_OutputType(MODE) ((MODE == HTS221_PUSHPULL) || (MODE == HTS221_OPENDRAIN))\n\n/**\n* @brief  Active level of DRDY pin.\n*/\ntypedef enum {\n  HTS221_HIGH_LVL   = (uint8_t)0x00,   /*!< HIGH state level for DRDY pin */\n  HTS221_LOW_LVL    = (uint8_t)0x80    /*!< LOW state level for DRDY pin */\n}HTS221_DrdyLevel_et;\n#define IS_HTS221_DrdyLevelType(MODE) ((MODE == HTS221_HIGH_LVL) || (MODE == HTS221_LOW_LVL))\n\n/**\n* @brief  Driver Version Info structure definition.\n*/\ntypedef struct\n{\n  uint8_t   Major;\n  uint8_t   Minor;\n  uint8_t   Point;\n}HTS221_DriverVersion_st;\n\n\n/**\n* @brief  HTS221 Init structure definition.\n*/\ntypedef struct\n{\n  HTS221_Avgh_et        avg_h;            /*!< Humidity average */\n  HTS221_Avgt_et        avg_t;            /*!< Temperature average */\n  HTS221_Odr_et         odr;              /*!< Output data rate */\n  HTS221_State_et       bdu_status;       /*!< HTS221_ENABLE/HTS221_DISABLE the block data update */\n  HTS221_State_et       heater_status;    /*!< HTS221_ENABLE/HTS221_DISABLE the internal heater */\n\n  HTS221_DrdyLevel_et   irq_level;        /*!< HTS221_HIGH_LVL/HTS221_LOW_LVL the level for DRDY pin */\n  HTS221_OutputType_et  irq_output_type;  /*!< Output configuration for DRDY pin */\n  HTS221_State_et       irq_enable;       /*!< HTS221_ENABLE/HTS221_DISABLE interrupt on DRDY pin */\n}HTS221_Init_st;\n\n/**\n* @}\n*/\n\n\n/* Exported Constants ---------------------------------------------------------*/\n/** @defgroup HTS221_Exported_Constants\n* @{\n*/\n\n/**\n* @brief  Bitfield positioning.\n*/\n#define HTS221_BIT(x) ((uint8_t)x)\n\n/**\n* @brief  I2C address.\n*/\n#define HTS221_I2C_ADDRESS  (uint8_t)AIR_HTS221_I2C_ADDRESS\n\n/**\n* @brief  I2C baudrate.\n*/\n#define HTS221_I2C_BAUD  400\n\n/**\n* @brief  Driver version.\n*/\n#define HTS221_DRIVER_VERSION_MAJOR (uint8_t)1\n#define HTS221_DRIVER_VERSION_MINOR (uint8_t)0\n#define HTS221_DRIVER_VERSION_POINT (uint8_t)0\n\n/**\n* @addtogroup HTS221_Registers\n* @{\n*/\n\n\n/**\n* @brief Device Identification register.\n* \\code\n* Read\n* Default value: 0xBC\n* 7:0 This read-only register contains the device identifier for HTS221.\n* \\endcode\n*/\n#define HTS221_WHO_AM_I_REG          (uint8_t)0x0F\n\n/**\n* @brief Device Identification value.\n*/\n#define HTS221_WHO_AM_I_VAL         (uint8_t)0xBC\n\n\n/**\n* @brief Humidity and temperature average mode register.\n* \\code\n* Read/write\n* Default value: 0x1B\n* 7:6 Reserved.\n* 5:3 AVGT2-AVGT1-AVGT0: Select the temperature internal average.\n*\n*      AVGT2 | AVGT1 | AVGT0 | Nr. Internal Average\n*   ----------------------------------------------------\n*       0    |   0   |   0   |    2\n*       0    |   0   |   1   |    4\n*       0    |   1   |   0   |    8\n*       0    |   1   |   1   |    16\n*       1    |   0   |   0   |    32\n*       1    |   0   |   1   |    64\n*       1    |   1   |   0   |    128\n*       1    |   1   |   1   |    256\n*\n* 2:0 AVGH2-AVGH1-AVGH0: Select humidity internal average.\n*      AVGH2 | AVGH1 |  AVGH0 | Nr. Internal Average\n*   ------------------------------------------------------\n*       0    |   0   |   0   |    4\n*       0    |   0   |   1   |    8\n*       0    |   1   |   0   |    16\n*       0    |   1   |   1   |    32\n*       1    |   0   |   0   |    64\n*       1    |   0   |   1   |    128\n*       1    |   1   |   0   |    256\n*       1    |   1   |   1   |    512\n*\n* \\endcode\n*/\n#define HTS221_AV_CONF_REG        (uint8_t)0x10\n\n#define HTS221_AVGT_BIT           HTS221_BIT(3)\n#define HTS221_AVGH_BIT           HTS221_BIT(0)\n\n#define HTS221_AVGH_MASK          (uint8_t)0x07\n#define HTS221_AVGT_MASK          (uint8_t)0x38\n\n/**\n* @brief Control register 1.\n* \\code\n* Read/write\n* Default value: 0x00\n* 7 PD: power down control. 0 - power down mode; 1 - active mode.\n* 6:3 Reserved.\n* 2 BDU: block data update. 0 - continuous update; 1 - output registers not updated until MSB and LSB reading.\n* 1:0 ODR1, ODR0: output data rate selection.\n*\n*   ODR1  | ODR0  | Humidity output data-rate(Hz)  | Pressure output data-rate(Hz)\n*   ----------------------------------------------------------------------------------\n*     0   |   0   |         one shot               |         one shot\n*     0   |   1   |            1                   |            1\n*     1   |   0   |            7                   |            7\n*     1   |   1   |           12.5                 |           12.5\n*\n* \\endcode\n*/\n#define HTS221_CTRL_REG1      (uint8_t)0x20\n\n#define HTS221_PD_BIT          HTS221_BIT(7)\n#define HTS221_BDU_BIT         HTS221_BIT(2)\n#define HTS221_ODR_BIT         HTS221_BIT(0)\n\n#define HTS221_PD_MASK        (uint8_t)0x80\n#define HTS221_BDU_MASK       (uint8_t)0x04\n#define HTS221_ODR_MASK       (uint8_t)0x03\n\n/**\n* @brief Control register 2.\n* \\code\n* Read/write\n* Default value: 0x00\n* 7 BOOT:  Reboot memory content. 0: normal mode; 1: reboot memory content. Self-cleared upon completation.\n* 6:2 Reserved.\n* 1 HEATHER: 0: heater enable; 1: heater disable.\n* 0 ONE_SHOT: 0: waiting for start of conversion; 1: start for a new dataset. Self-cleared upon completation.\n* \\endcode\n*/\n#define HTS221_CTRL_REG2      (uint8_t)0x21\n\n#define HTS221_BOOT_BIT        HTS221_BIT(7)\n#define HTS221_HEATHER_BIT     HTS221_BIT(1)\n#define HTS221_ONESHOT_BIT     HTS221_BIT(0)\n\n#define HTS221_BOOT_MASK      (uint8_t)0x80\n#define HTS221_HEATHER_MASK   (uint8_t)0x02\n#define HTS221_ONE_SHOT_MASK  (uint8_t)0x01\n\n/**\n* @brief Control register 3.\n* \\code\n* Read/write\n* Default value: 0x00\n* 7 DRDY_H_L: Interrupt edge. 0: active high, 1: active low.\n* 6 PP_OD: Push-Pull/OpenDrain selection on interrupt pads. 0: push-pull; 1: open drain.\n* 5:3 Reserved.\n* 2 DRDY: interrupt config. 0: disable, 1: enable.\n* \\endcode\n*/\n#define HTS221_CTRL_REG3      (uint8_t)0x22\n\n#define HTS221_DRDY_H_L_BIT    HTS221_BIT(7)\n#define HTS221_PP_OD_BIT       HTS221_BIT(6)\n#define HTS221_DRDY_BIT        HTS221_BIT(2)\n\n#define HTS221_DRDY_H_L_MASK  (uint8_t)0x80\n#define HTS221_PP_OD_MASK     (uint8_t)0x40\n#define HTS221_DRDY_MASK      (uint8_t)0x04\n\n/**\n* @brief  Status register.\n* \\code\n* Read\n* Default value: 0x00\n* 7:2 Reserved.\n* 1 H_DA: Humidity data available. 0: new data for humidity is not yet available; 1: new data for humidity is available.\n* 0 T_DA: Temperature data available. 0: new data for temperature is not yet available; 1: new data for temperature is available.\n* \\endcode\n*/\n#define HTS221_STATUS_REG    (uint8_t)0x27\n\n#define HTS221_H_DA_BIT       HTS221_BIT(1)\n#define HTS221_T_DA_BIT       HTS221_BIT(0)\n\n#define HTS221_HDA_MASK      (uint8_t)0x02\n#define HTS221_TDA_MASK      (uint8_t)0x01\n\n/**\n* @brief  Humidity data (LSB).\n* \\code\n* Read\n* Default value: 0x00.\n* HOUT7 - HOUT0: Humidity data LSB (2's complement).\n* \\endcode\n*/\n#define HTS221_HR_OUT_L_REG        (uint8_t)0x28\n\n/**\n* @brief  Humidity data (MSB).\n* \\code\n* Read\n* Default value: 0x00.\n* HOUT15 - HOUT8: Humidity data MSB (2's complement).\n* \\endcode\n*/\n#define HTS221_HR_OUT_H_REG        (uint8_t)0x29\n\n\n/**\n* @brief  Temperature data (LSB).\n* \\code\n* Read\n* Default value: 0x00.\n* TOUT7 - TOUT0: temperature data LSB.\n* \\endcode\n*/\n#define HTS221_TEMP_OUT_L_REG         (uint8_t)0x2A\n\n/**\n* @brief  Temperature data (MSB).\n* \\code\n* Read\n* Default value: 0x00.\n* TOUT15 - TOUT8: temperature data MSB.\n* \\endcode\n*/\n#define HTS221_TEMP_OUT_H_REG         (uint8_t)0x2B\n\n/**\n* @brief  Calibration registers.\n* \\code\n* Read\n* \\endcode\n*/\n#define HTS221_H0_RH_X2        (uint8_t)0x30\n#define HTS221_H1_RH_X2        (uint8_t)0x31\n#define HTS221_T0_DEGC_X8      (uint8_t)0x32\n#define HTS221_T1_DEGC_X8      (uint8_t)0x33\n#define HTS221_T0_T1_DEGC_H2   (uint8_t)0x35\n#define HTS221_H0_T0_OUT_L     (uint8_t)0x36\n#define HTS221_H0_T0_OUT_H     (uint8_t)0x37\n#define HTS221_H1_T0_OUT_L     (uint8_t)0x3A\n#define HTS221_H1_T0_OUT_H     (uint8_t)0x3B\n#define HTS221_T0_OUT_L        (uint8_t)0x3C\n#define HTS221_T0_OUT_H        (uint8_t)0x3D\n#define HTS221_T1_OUT_L        (uint8_t)0x3E\n#define HTS221_T1_OUT_H        (uint8_t)0x3F\n\n\n/**\n* @}\n*/\n\n\n/**\n* @}\n*/\n\n\n/* Exported Functions -------------------------------------------------------------*/\n/** @defgroup HTS221_Exported_Functions\n* @{\n*/\n\n#define HTS221_HalInit                                  HAL_Init_I2C\n#define HTS221_HalDeInit                                HAL_DeInit_I2C\n\n// the user must redefine the proper HTS221_ReadReg\n//#define HTS221_ReadReg(RegAddr, NumByteToRead, Data)    HAL_ReadReg(HTS221_I2C_ADDRESS, RegAddr, NumByteToRead, Data)\n\n// the user must redefine the proper HTS221_WriteReg\n//#define HTS221_WriteReg(RegAddr, NumByteToWrite, Data)  HAL_WriteReg(HTS221_I2C_ADDRESS, RegAddr, NumByteToWrite, Data)\n\n\nHTS221_Error_et HTS221_WriteReg(uint8_t RegAddr, uint16_t NumByteToWrite, uint8_t* Data);\nHTS221_Error_et HTS221_ReadReg(uint8_t RegAddr, uint16_t NumByteToWrite, uint8_t* Data);\n\n\n// HTS221_Error_et HTS221_Get_DriverVersion(HTS221_DriverVersion_st* version);\nHTS221_Error_et HTS221_Get_DeviceID(uint8_t* deviceid);\n\nHTS221_Error_et HTS221_Set_InitConfig(HTS221_Init_st* pxInit);\nHTS221_Error_et HTS221_Get_InitConfig(HTS221_Init_st* pxInit);\nHTS221_Error_et HTS221_DeInit(void);\nHTS221_Error_et HTS221_IsMeasurementCompleted(HTS221_BitStatus_et* Is_Measurement_Completed);\n\nHTS221_Error_et HTS221_Get_Measurement(uint16_t* humidity, int16_t* temperature);\nHTS221_Error_et HTS221_Get_RawMeasurement(int16_t* humidity, int16_t* temperature);\nHTS221_Error_et HTS221_Get_Humidity(uint16_t* value);\nHTS221_Error_et HTS221_Get_HumidityRaw(int16_t* value);\nHTS221_Error_et HTS221_Get_TemperatureRaw(int16_t* value);\nHTS221_Error_et HTS221_Get_Temperature(int16_t* value);\nHTS221_Error_et HTS221_Get_DataStatus(HTS221_BitStatus_et* humidity, HTS221_BitStatus_et* temperature);\nHTS221_Error_et HTS221_Activate(void);\nHTS221_Error_et HTS221_DeActivate(void);\n\nHTS221_Error_et HTS221_Set_AvgHT(HTS221_Avgh_et avgh, HTS221_Avgt_et avgt);\nHTS221_Error_et HTS221_Set_AvgH(HTS221_Avgh_et avgh);\nHTS221_Error_et HTS221_Set_AvgT(HTS221_Avgt_et avgt);\nHTS221_Error_et HTS221_Get_AvgHT(HTS221_Avgh_et* avgh, HTS221_Avgt_et* avgt);\nHTS221_Error_et HTS221_Set_BduMode(HTS221_State_et status);\nHTS221_Error_et HTS221_Get_BduMode(HTS221_State_et* status);\nHTS221_Error_et HTS221_Set_PowerDownMode(HTS221_BitStatus_et status);\nHTS221_Error_et HTS221_Get_PowerDownMode(HTS221_BitStatus_et* status);\nHTS221_Error_et HTS221_Set_Odr(HTS221_Odr_et odr);\nHTS221_Error_et HTS221_Get_Odr(HTS221_Odr_et* odr);\nHTS221_Error_et HTS221_MemoryBoot(void);\nHTS221_Error_et HTS221_Set_HeaterState(HTS221_State_et status);\nHTS221_Error_et HTS221_Get_HeaterState(HTS221_State_et* status);\nHTS221_Error_et HTS221_StartOneShotMeasurement(void);\nHTS221_Error_et HTS221_Set_IrqActiveLevel(HTS221_DrdyLevel_et status);\nHTS221_Error_et HTS221_Get_IrqActiveLevel(HTS221_DrdyLevel_et* status);\nHTS221_Error_et HTS221_Set_IrqOutputType(HTS221_OutputType_et value);\nHTS221_Error_et HTS221_Get_IrqOutputType(HTS221_OutputType_et* value);\nHTS221_Error_et HTS221_Set_IrqEnable(HTS221_State_et status);\nHTS221_Error_et HTS221_Get_IrqEnable(HTS221_State_et* status);\n\n\nHTS221_Error_et HTS221_Setup(HTS221_Init_st* pxInit);\n\n#ifdef __cplusplus\n}\n#endif\n\n\n/**\n* @}\n*/\n\n/**\n* @}\n*/\n\n/**\n* @}\n*/\n\n#endif /* __HTS221_DRIVER__H */\n\n/******************* (C) COPYRIGHT 2013 STMicroelectronics *****END OF FILE****/\n"
            },
            "objects": {
                "hts221.c": "/**\n *\t----------------------------------------------------------------------------\n *\tCopyright (c) 2016, Anaren Microwave, Inc.\n *\n *\tFor more information on licensing, please see Anaren Microwave, Inc's\n *\tend user software licensing agreement: EULA.txt.\n *\n *\t----------------------------------------------------------------------------\n *\n *\thmc5883.c - driver interface for the Honeywell HMC5883L 3-Axis Digital\n *\tCompass.\n *\n *\t@version\t\t1.0.00\n *\t@date\t\t\t 14 Mar 2016\n *\t@author\t\t Anaren, air@anaren.com\n *\n *\tassumptions\n *\t===========\n *\t- The i2c driver provides the proper signaling sequences for read & write\n *\t\toperations.\n *\t- The i2c driver meets the timing requirements specified in the HMC5883L\n *\t\tdatasheet.\n *\n *\tfile dependency\n *\t===============\n *\ti2c.h : defines the i2c read & write interfaces.\n *\n *\trevision history\n *\t================\n *\tver 1.0.00 : 14 Mar 2016\n *\t- initial release\n */\n\n/* Includes ------------------------------------------------------------------*/\n#include \"hts221.h\"\n#ifdef  USE_FULL_ASSERT_HTS221\n#include <stdio.h>\n\n#endif\n\n\n\n/** @addtogroup Environmental_Sensor\n* @{\n*/\n\n/** @defgroup HTS221_DRIVER\n* @brief HTS221 DRIVER\n* @{\n*/\n\n\n/** @defgroup HTS221_Public_Functions\n* @{\n*/\n\n/**\n * @brief  Setup the Init struct with default values\n * @param  pxInit pointer to a HTS221_Init_st structure that contains the configuration.\n *         This parameter is a pointer to @ref HTS221_Init_st.\n * @retval Error code [HTS221_OK, HTS221_ERROR].\n */\nHTS221_Error_et HTS221_Setup(HTS221_Init_st* pxInit)\n{\n\tuint8_t htsDeviceID;\n\tHTS221_Get_DeviceID(&htsDeviceID); //verify device ID\n\n\tif(htsDeviceID != 0xBC)\n\t\treturn HTS221_ERROR;\n\n\tpxInit->avg_h = HTS221_AVGH_32; \t\t//samples to use; default 32\n\tpxInit->avg_t = HTS221_AVGT_16; \t\t//samples to use; default 16\n\tpxInit->bdu_status = HTS221_ENABLE; \t//HTS221_ENABLE: enable the block data update, output data registers are updated once both MSB and LSB are read.\n\tpxInit->heater_status = HTS221_DISABLE; //disable internal heater\n\tpxInit->irq_enable = HTS221_DISABLE; \t//disable irq\n\tpxInit->irq_level = HTS221_LOW_LVL;\n\tpxInit->irq_output_type = HTS221_PUSHPULL;\n\tpxInit->odr = HTS221_ODR_1HZ; \t\t\t//update temp/humidity @ 1hz\n\n\tHTS221_Set_InitConfig(pxInit);  \t\t//Write config to device\n\n\tHTS221_Set_PowerDownMode(HTS221_SET); \t//Turn on device\n\n\treturn HTS221_OK;\n}\n\n\n/**\n* @brief  Get the version of this driver.\n* @param  pxVersion pointer to a HTS221_DriverVersion_st structure that contains the version information.\n*         This parameter is a pointer to @ref HTS221_DriverVersion_st.\n* @retval Error code [HTS221_OK, HTS221_ERROR].\n*/\nHTS221_Error_et HTS221_Get_DriverVersion(HTS221_DriverVersion_st* version)\n{\n\tversion->Major = HTS221_DRIVER_VERSION_MAJOR;\n\tversion->Minor = HTS221_DRIVER_VERSION_MINOR;\n\tversion->Point = HTS221_DRIVER_VERSION_POINT;\n\n\treturn HTS221_OK;\n}\n\n/**\n* @brief  Get device type ID.\n* @param  deviceid pointer to the returned device type ID.\n* @retval Error code [HTS221_OK, HTS221_ERROR].\n*/\nHTS221_Error_et HTS221_Get_DeviceID(uint8_t* deviceid)\n{\n\tif(HTS221_ReadReg(HTS221_WHO_AM_I_REG, 1, deviceid))\n\t\treturn HTS221_ERROR;\n\n\treturn HTS221_OK;\n}\n\n/**\n * @brief  Initializes the HTS221 with the specified parameters in HTS221_Init_st struct.\n * @param  pxInit pointer to a HTS221_Init_st structure that contains the configuration.\n *         This parameter is a pointer to @ref HTS221_Init_st.\n * @retval Error code [HTS221_OK, HTS221_ERROR].\n */\nHTS221_Error_et HTS221_Set_InitConfig(HTS221_Init_st* pxInit)\n{\n\tuint8_t buffer[3];\n\n\tHTS221_assert_param(IS_HTS221_AVGH(pxInit->avg_h));\n\tHTS221_assert_param(IS_HTS221_AVGT(pxInit->avg_t));\n\tHTS221_assert_param(IS_HTS221_ODR(pxInit->odr));\n\tHTS221_assert_param(IS_HTS221_State(pxInit->bdu_status));\n\tHTS221_assert_param(IS_HTS221_State(pxInit->heater_status));\n\n\tHTS221_assert_param(IS_HTS221_DrdyLevelType(pxInit->irq_level));\n\tHTS221_assert_param(IS_HTS221_OutputType(pxInit->irq_output_type));\n\tHTS221_assert_param(IS_HTS221_State(pxInit->irq_enable));\n\n\tif(HTS221_ReadReg(HTS221_AV_CONF_REG, 1, buffer))\n\t\treturn HTS221_ERROR;\n\n\tbuffer[0] &= ~(HTS221_AVGH_MASK | HTS221_AVGT_MASK);\n\tbuffer[0] |= (uint8_t)pxInit->avg_h;\n\tbuffer[0] |= (uint8_t)pxInit->avg_t;\n\n\tif(HTS221_WriteReg(HTS221_AV_CONF_REG, 1, buffer))\n\t\treturn HTS221_ERROR;\n\n\tif(HTS221_ReadReg(HTS221_CTRL_REG1, 3, buffer))\n\t\treturn HTS221_ERROR;\n\n\tbuffer[0] &= ~(HTS221_BDU_MASK | HTS221_ODR_MASK);\n\tbuffer[0] |= (uint8_t)pxInit->odr;\n\tbuffer[0] |= ((uint8_t)pxInit->bdu_status)<<HTS221_BDU_BIT;\n\n\tbuffer[1] &= ~HTS221_HEATHER_BIT;\n\tbuffer[1] |= ((uint8_t)pxInit->heater_status)<<HTS221_HEATHER_BIT;\n\n\tbuffer[2] &= ~(HTS221_DRDY_H_L_MASK | HTS221_PP_OD_MASK | HTS221_DRDY_MASK);\n\tbuffer[2] |= ((uint8_t)pxInit->irq_level)<<HTS221_DRDY_H_L_BIT;\n\tbuffer[2] |= (uint8_t)pxInit->irq_output_type;\n\tbuffer[2] |= ((uint8_t)pxInit->irq_enable)<<HTS221_DRDY_BIT;\n\n\tif(HTS221_WriteReg(HTS221_CTRL_REG1, 3, buffer))\n\t\treturn HTS221_ERROR;\n\n\treturn HTS221_OK;\n}\n\n/**\n * @brief  Returns a HTS221_Init_st struct with the actual configuration.\n * @param  pxInit pointer to a HTS221_Init_st structure.\n *         This parameter is a pointer to @ref HTS221_Init_st.\n * @retval Error code [HTS221_OK, HTS221_ERROR].\n */\nHTS221_Error_et HTS221_Get_InitConfig(HTS221_Init_st* pxInit)\n{\n\tuint8_t buffer[3];\n\n\tif(HTS221_ReadReg(HTS221_AV_CONF_REG, 1, buffer))\n\t\treturn HTS221_ERROR;\n\n\tpxInit->avg_h = (HTS221_Avgh_et)(buffer[0] & HTS221_AVGH_MASK);\n\tpxInit->avg_t = (HTS221_Avgt_et)(buffer[0] & HTS221_AVGT_MASK);\n\n\tif(HTS221_ReadReg(HTS221_CTRL_REG1, 3, buffer))\n\t\treturn HTS221_ERROR;\n\n\tpxInit->odr = (HTS221_Odr_et)(buffer[0] & HTS221_ODR_MASK);\n\tpxInit->bdu_status = (HTS221_State_et)((buffer[0] & HTS221_BDU_MASK) >> HTS221_BDU_BIT);\n\tpxInit->heater_status = (HTS221_State_et)((buffer[1] & HTS221_HEATHER_MASK) >> HTS221_HEATHER_BIT);\n\n\tpxInit->irq_level = (HTS221_DrdyLevel_et)(buffer[2] & HTS221_DRDY_H_L_MASK);\n\tpxInit->irq_output_type = (HTS221_OutputType_et)(buffer[2] & HTS221_PP_OD_MASK);\n\tpxInit->irq_enable = (HTS221_State_et)((buffer[2] & HTS221_DRDY_MASK) >> HTS221_DRDY_BIT);\n\n\treturn HTS221_OK;\n}\n\n/**\n* @brief  De initialization function for HTS221.\n*         This function put the HTS221 in power down, make a memory boot and clear the data output flags.\n* @param  None.\n* @retval Error code [HTS221_OK, HTS221_ERROR].\n*/\nHTS221_Error_et HTS221_DeInit(void)\n{\n\tuint8_t buffer[4];\n\n\tif(HTS221_ReadReg(HTS221_CTRL_REG1, 2, buffer))\n\t\treturn HTS221_ERROR;\n\n\t/* HTS221 in power down */\n\tbuffer[0] |= 0x01<<HTS221_PD_BIT;\n\n\t/* Make HTS221 boot */\n\tbuffer[1] |= 0x01<<HTS221_BOOT_BIT;\n\n\tif(HTS221_WriteReg(HTS221_CTRL_REG1, 2, buffer))\n\t\treturn HTS221_ERROR;\n\n\t/* Dump of data output */\n\tif(HTS221_ReadReg(HTS221_HR_OUT_L_REG, 4, buffer))\n\t\treturn HTS221_ERROR;\n\n\treturn HTS221_OK;\n}\n\n/**\n* @brief  Read HTS221 output registers, and calculate humidity and temperature.\n* @param  humidity pointer to the returned humidity value that must be divided by 10 to get the value in [%].\n* @param  temperature pointer to the returned temperature value that must be divided by 10 to get the value in ['C].\n* @retval Error code [HTS221_OK, HTS221_ERROR].\n*/\nHTS221_Error_et HTS221_Get_Measurement(uint16_t* humidity, int16_t* temperature)\n{\n\tint16_t H0_T0_out, H1_T0_out, H_T_out;\n\tint16_t T0_out, T1_out, T_out, T0_degC_x8_u16, T1_degC_x8_u16;\n\tint16_t H0_rh, H1_rh;\n\tint16_t T0_degC, T1_degC;\n\tuint8_t buffer[8];\n\tint32_t tmp;\n\n\tif(HTS221_ReadReg(HTS221_HR_OUT_L_REG, 4, buffer))\n\t\treturn HTS221_ERROR;\n\n\tH_T_out = (((uint16_t)buffer[1])<<8) | (uint16_t)buffer[0];\n\tT_out = (((uint16_t)buffer[3])<<8) | (uint16_t)buffer[2];\n\n\tif(HTS221_ReadReg(HTS221_H0_RH_X2, 4, buffer))\n\t\treturn HTS221_ERROR;\n\n\tH0_rh = buffer[0]>>1;\n\tH1_rh = buffer[1]>>1;\n\n\tT0_degC_x8_u16 = (uint16_t)buffer[2];\n\tT1_degC_x8_u16 = (uint16_t)buffer[3];\n\n\tif(HTS221_ReadReg(HTS221_T0_T1_DEGC_H2, 3, buffer))\n\t\treturn HTS221_ERROR;\n\n\tT0_degC_x8_u16 |= (((uint16_t)(buffer[0] & 0x03)) << 8);\n\tT1_degC_x8_u16 |= (((uint16_t)(buffer[0] & 0x0C)) << 6);\n\tT0_degC = T0_degC_x8_u16>>3;\n\tT1_degC = T1_degC_x8_u16>>3;\n\n\tH0_T0_out = (((uint16_t)buffer[2])<<8) | (uint16_t)buffer[1];\n\n\tif(HTS221_ReadReg(HTS221_H1_T0_OUT_L, 6, buffer))\n\t\treturn HTS221_ERROR;\n\n\tH1_T0_out = (((uint16_t)buffer[1])<<8) | (uint16_t)buffer[0];\n\tT0_out = (((uint16_t)buffer[3])<<8) | (uint16_t)buffer[2];\n\tT1_out = (((uint16_t)buffer[5])<<8) | (uint16_t)buffer[4];\n\n\ttmp = ((uint32_t)(H_T_out - H0_T0_out)) * ((uint32_t)(H1_rh - H0_rh)*10);\n\t*humidity =    tmp/(H1_T0_out - H0_T0_out)  + H0_rh*10;\n\n\ttmp = ((int32_t)(T_out - T0_out)) * ((int32_t)(T1_degC - T0_degC)*10);\n\t*temperature = tmp /(T1_out - T0_out) + T0_degC*10;\n\n\tif(*humidity>1000) *humidity = 1000;\n\n\treturn HTS221_OK;\n}\n\n/**\n* @brief  Read HTS221 output registers. Humidity and temperature.\n* @param  humidity pointer to the returned humidity raw value.\n* @param  temperature pointer to the returned temperature raw value.\n* @retval Error code [HTS221_OK, HTS221_ERROR].\n*/\nHTS221_Error_et HTS221_Get_RawMeasurement(int16_t* humidity, int16_t* temperature)\n{\n\tuint8_t buffer[4];\n\n\tif(HTS221_ReadReg(HTS221_HR_OUT_L_REG, 4, buffer))\n\t\treturn HTS221_ERROR;\n\n\t*humidity = (int16_t)((((uint16_t)buffer[1])<<8) | (uint16_t)buffer[0]);\n\t*temperature = (int16_t)((((uint16_t)buffer[3])<<8) | (uint16_t)buffer[2]);\n\n\treturn HTS221_OK;\n}\n\n/**\n* @brief  Read HTS221 Humidity output registers, and calculate humidity.\n* @param  Pointer to the returned humidity value that must be divided by 10 to get the value in [%].\n* @retval Error code [HTS221_OK, HTS221_ERROR].\n*/\nHTS221_Error_et HTS221_Get_Humidity(uint16_t* value)\n{\n\tint16_t H0_T0_out, H1_T0_out, H_T_out;\n\tint16_t H0_rh, H1_rh;\n\tuint8_t buffer[2];\n\tuint32_t tmp;\n\n\tif(HTS221_ReadReg(HTS221_H0_RH_X2, 2, buffer))\n\t\treturn HTS221_ERROR;\n\t\n\tH0_rh = buffer[0]>>1;\n\tH1_rh = buffer[1]>>1;\n\n\tif(HTS221_ReadReg(HTS221_H0_T0_OUT_L, 2, buffer))\n\t\treturn HTS221_ERROR;\n\t\n\tH0_T0_out = (((uint16_t)buffer[1])<<8) | (uint16_t)buffer[0];\n\n\tif(HTS221_ReadReg(HTS221_H1_T0_OUT_L, 2, buffer))\n\t\treturn HTS221_ERROR;\n\t\n\tH1_T0_out = (((uint16_t)buffer[1])<<8) | (uint16_t)buffer[0];\n\n\tif(HTS221_ReadReg(HTS221_HR_OUT_L_REG, 2, buffer))\n\t\treturn HTS221_ERROR;\n\t\n\tH_T_out = (((uint16_t)buffer[1])<<8) | (uint16_t)buffer[0];\n\n\ttmp = ((uint32_t)(H_T_out - H0_T0_out)) * ((uint32_t)(H1_rh - H0_rh)*10);\n\t*value =    tmp/(H1_T0_out - H0_T0_out)  + H0_rh*10;\n\n\tif(*value>1000) *value = 1000;\n\n\treturn HTS221_OK;\n}\n\n/**\n* @brief  Read HTS221 humidity output registers.\n* @param  Pointer to the returned humidity raw value.\n* @retval Error code [HTS221_OK, HTS221_ERROR].\n*/\nHTS221_Error_et HTS221_Get_HumidityRaw(int16_t* value)\n{\n\tuint8_t buffer[2];\n\n\tif(HTS221_ReadReg(HTS221_HR_OUT_L_REG, 2, buffer))\n\t\treturn HTS221_ERROR;\n\n\t*value = (int16_t)((((uint16_t)buffer[1])<<8) | (uint16_t)buffer[0]);\n\n\treturn HTS221_OK;\n}\n\n/**\n* @brief  Read HTS221 temperature output registers, and calculate temperature.\n* @param  Pointer to the returned temperature value that must be divided by 10 to get the value in ['C].\n* @retval Error code [HTS221_OK, HTS221_ERROR].\n*/\nHTS221_Error_et HTS221_Get_Temperature(int16_t *value)\n{\n\tint16_t T0_out, T1_out, T_out, T0_degC_x8_u16, T1_degC_x8_u16;\n\tint16_t T0_degC, T1_degC;\n\tuint8_t buffer[4], tmp;\n\tuint32_t tmp32;\n\n\tif(HTS221_ReadReg(HTS221_T0_DEGC_X8, 2, buffer))\n\t\treturn HTS221_ERROR;\n\t\n\tif(HTS221_ReadReg(HTS221_T0_T1_DEGC_H2, 1, &tmp))\n\t\treturn HTS221_ERROR;\n\n\tT0_degC_x8_u16 = (((uint16_t)(tmp & 0x03)) << 8) | ((uint16_t)buffer[0]);\n\tT1_degC_x8_u16 = (((uint16_t)(tmp & 0x0C)) << 6) | ((uint16_t)buffer[1]);\n\tT0_degC = T0_degC_x8_u16>>3;\n\tT1_degC = T1_degC_x8_u16>>3;\n\n\tif(HTS221_ReadReg(HTS221_T0_OUT_L, 4, buffer))\n\t\treturn HTS221_ERROR;\n\n\tT0_out = (((uint16_t)buffer[1])<<8) | (uint16_t)buffer[0];\n\tT1_out = (((uint16_t)buffer[3])<<8) | (uint16_t)buffer[2];\n\n\tif(HTS221_ReadReg(HTS221_TEMP_OUT_L_REG, 2, buffer))\n\treturn HTS221_ERROR;\n\n\tT_out = (((uint16_t)buffer[1])<<8) | (uint16_t)buffer[0];\n\n\ttmp32 = ((uint32_t)(T_out - T0_out)) * ((uint32_t)(T1_degC - T0_degC)*10);\n\t*value = tmp32 /(T1_out - T0_out)  + T0_degC*10;\n\n\treturn HTS221_OK;\n}\n\n/**\n* @brief  Read HTS221 temperature output registers.\n* @param  Pointer to the returned temperature raw value.\n* @retval Error code [HTS221_OK, HTS221_ERROR].\n*/\nHTS221_Error_et HTS221_Get_TemperatureRaw(int16_t* value)\n{\n\tuint8_t buffer[2];\n\n\tif(HTS221_ReadReg(HTS221_TEMP_OUT_L_REG, 2, buffer))\n\t\treturn HTS221_ERROR;\n\n\t*value = (int16_t)((((uint16_t)buffer[1])<<8) | (uint16_t)buffer[0]);\n\n\treturn HTS221_OK;\n}\n\n/**\n* @brief  Get the availability of new data for humidity and temperature.\n* @param  humidity pointer to the returned humidity data status [HTS221_SET/HTS221_RESET].\n* @param  temperature pointer to the returned temperature data status [HTS221_SET/HTS221_RESET].\n*         This parameter is a pointer to @ref HTS221_BitStatus_et.\n* @retval Error code [HTS221_OK, HTS221_ERROR].\n*/\nHTS221_Error_et HTS221_Get_DataStatus(HTS221_BitStatus_et* humidity, HTS221_BitStatus_et* temperature)\n{\n\tuint8_t tmp;\n\n\tif(HTS221_ReadReg(HTS221_STATUS_REG, 1, &tmp))\n\t\treturn HTS221_ERROR;\n\n\t*humidity = (HTS221_BitStatus_et)((tmp & HTS221_HDA_MASK)>>HTS221_H_DA_BIT);\n\t*temperature = (HTS221_BitStatus_et)(tmp & HTS221_TDA_MASK);\n\n\treturn HTS221_OK;\n}\n\n/**\n* @brief  Exit from power down mode.\n* @param  void.\n* @retval Error code [HTS221_OK, HTS221_ERROR].\n*/\nHTS221_Error_et HTS221_Activate(void)\n{\n\tuint8_t tmp;\n\n\tif(HTS221_ReadReg(HTS221_CTRL_REG1, 1, &tmp))\n\t\treturn HTS221_ERROR;\n\n\ttmp &= ~HTS221_PD_MASK;\n\n\tif(HTS221_WriteReg(HTS221_CTRL_REG1, 1, &tmp))\n\t\treturn HTS221_ERROR;\n\n\treturn HTS221_OK;\n}\n\n/**\n* @brief  Put the sensor in power down mode.\n* @param  void.\n* @retval Error code [HTS221_OK, HTS221_ERROR].\n*/\nHTS221_Error_et HTS221_DeActivate(void)\n{\n\tuint8_t tmp;\n\n\tif(HTS221_ReadReg(HTS221_CTRL_REG1, 1, &tmp))\n\t\treturn HTS221_ERROR;\n\n\ttmp |= HTS221_PD_MASK;\n\n\tif(HTS221_WriteReg(HTS221_CTRL_REG1, 1, &tmp))\n\t\treturn HTS221_ERROR;\n\n\treturn HTS221_OK;\n}\n\n\n\n/**\n  * @brief  Check if the single measurement has completed.\n* @param  tmp is set to 1, when the measure is completed\n  * @retval Status [LPS25H_ERROR, LPS25H_OK]\n*/\nHTS221_Error_et HTS221_IsMeasurementCompleted(HTS221_BitStatus_et* Is_Measurement_Completed)\n{\n\tuint8_t tmp;\n\n\tif(HTS221_ReadReg(HTS221_STATUS_REG, 1, &tmp))\n\t\t\treturn HTS221_ERROR;\n\n\tif((tmp & (uint8_t)(HTS221_HDA_MASK | HTS221_TDA_MASK)) == (uint8_t)(HTS221_HDA_MASK | HTS221_TDA_MASK))\n\t\t*Is_Measurement_Completed = HTS221_SET;\n\telse\n\t\t*Is_Measurement_Completed = HTS221_RESET;\n\n\treturn HTS221_OK;\n }\n\n\n/**\n* @brief  Set_ humidity and temperature average mode.\n* @param  avgh is the average mode for humidity, this parameter is @ref HTS221_Avgh_et.\n* @param  avgt is the average mode for temperature, this parameter is @ref HTS221_Avgt_et.\n* @retval Error code [HTS221_OK, HTS221_ERROR].\n*/\nHTS221_Error_et HTS221_Set_AvgHT(HTS221_Avgh_et avgh, HTS221_Avgt_et avgt)\n{\n\tuint8_t tmp;\n\n\tHTS221_assert_param(IS_HTS221_AVGH(avgh));\n\tHTS221_assert_param(IS_HTS221_AVGT(avgt));\n\n\tif(HTS221_ReadReg(HTS221_AV_CONF_REG, 1, &tmp))\n\t\treturn HTS221_ERROR;\n\n\ttmp &= ~(HTS221_AVGH_MASK | HTS221_AVGT_MASK);\n\ttmp |= (uint8_t)avgh;\n\ttmp |= (uint8_t)avgt;\n\n\tif(HTS221_WriteReg(HTS221_AV_CONF_REG, 1, &tmp))\n\t\treturn HTS221_ERROR;\n\n\treturn HTS221_OK;\n}\n\n/**\n* @brief  Set humidity average mode.\n* @param  avgh is the average mode for humidity, this parameter is @ref HTS221_Avgh_et.\n* @retval Error code [HTS221_OK, HTS221_ERROR].\n*/\nHTS221_Error_et HTS221_Set_AvgH(HTS221_Avgh_et avgh)\n{\n\tuint8_t tmp;\n\n\tHTS221_assert_param(IS_HTS221_AVGH(avgh));\n\n\tif(HTS221_ReadReg(HTS221_AV_CONF_REG, 1, &tmp))\n\t\treturn HTS221_ERROR;\n\n\ttmp &= ~HTS221_AVGH_MASK;\n\ttmp |= (uint8_t)avgh;\n\n\tif(HTS221_WriteReg(HTS221_AV_CONF_REG, 1, &tmp))\n\t\treturn HTS221_ERROR;\n\n\treturn HTS221_OK;\n}\n\n/**\n* @brief  Set temperature average mode.\n* @param  avgt is the average mode for temperature, this parameter is @ref HTS221_Avgt_et.\n* @retval Error code [HTS221_OK, HTS221_ERROR].\n*/\nHTS221_Error_et HTS221_Set_AvgT(HTS221_Avgt_et avgt)\n{\n\tuint8_t tmp;\n\n\tHTS221_assert_param(IS_HTS221_AVGT(avgt));\n\n\tif(HTS221_ReadReg(HTS221_AV_CONF_REG, 1, &tmp))\n\t\treturn HTS221_ERROR;\n\n\ttmp &= ~HTS221_AVGT_MASK;\n\ttmp |= (uint8_t)avgt;\n\n\tif(HTS221_WriteReg(HTS221_AV_CONF_REG, 1, &tmp))\n\t\treturn HTS221_ERROR;\n\n\treturn HTS221_OK;\n}\n\n/**\n* @brief  Get humidity and temperature average mode.\n* @param  avgh pointer to the returned value with the humidity average mode.\n* @param  avgt pointer to the returned value with the temperature average mode.\n* @retval Error code [HTS221_OK, HTS221_ERROR].\n*/\nHTS221_Error_et HTS221_Get_AvgHT(HTS221_Avgh_et* avgh, HTS221_Avgt_et* avgt)\n{\n\tuint8_t tmp;\n\n\tif(HTS221_ReadReg(HTS221_AV_CONF_REG, 1, &tmp))\n\t\treturn HTS221_ERROR;\n\n\t*avgh = (HTS221_Avgh_et)(tmp & HTS221_AVGH_MASK);\n\t*avgt = (HTS221_Avgt_et)(tmp & HTS221_AVGT_MASK);\n\n\treturn HTS221_OK;\n}\n\n/**\n* @brief  Set block data update mode.\n* @param  status can be HTS221_ENABLE: enable the block data update, output data registers are updated once both MSB and LSB are read.\n* @param  status can be HTS221_DISABLE: output data registers are continuously updated.\n*         This parameter is a @ref HTS221_BitStatus_et.\n* @retval Error code [HTS221_OK, HTS221_ERROR].\n*/\nHTS221_Error_et HTS221_Set_BduMode(HTS221_State_et status)\n{\n\tuint8_t tmp;\n\n\tHTS221_assert_param(IS_HTS221_State(status));\n\n\tif(HTS221_ReadReg(HTS221_CTRL_REG1, 1, &tmp))\n\t\treturn HTS221_ERROR;\n\n\ttmp &= ~HTS221_BDU_MASK;\n\ttmp |= ((uint8_t)status)<<HTS221_BDU_BIT;\n\n\tif(HTS221_WriteReg(HTS221_CTRL_REG1, 1, &tmp))\n\t\treturn HTS221_ERROR;\n\n\treturn HTS221_OK;\n}\n\n/**\n* @brief  Get block data update mode.\n* @param  Pointer to the returned value with block data update mode status.\n* @retval Error code [HTS221_OK, HTS221_ERROR].\n*/\nHTS221_Error_et HTS221_Get_BduMode(HTS221_State_et* status)\n{\n\tuint8_t tmp;\n\n\tif(HTS221_ReadReg(HTS221_CTRL_REG1, 1, &tmp))\n\t\treturn HTS221_ERROR;\n\n\t*status = (HTS221_State_et)((tmp & HTS221_BDU_MASK) >> HTS221_BDU_BIT);\n\n\treturn HTS221_OK;\n}\n\n/**\n* @brief  Enter or exit from power down mode.\n* @param  status can be HTS221_SET: HTS221 in power down mode.\n* @param  status can be HTS221_REET: HTS221 in active mode.\n*         This parameter is a @ref HTS221_BitStatus_et.\n* @retval Error code [HTS221_OK, HTS221_ERROR].\n*/\nHTS221_Error_et HTS221_Set_PowerDownMode(HTS221_BitStatus_et status)\n{\n\tuint8_t tmp;\n\n\tHTS221_assert_param(IS_HTS221_BitStatus(status));\n\n\tif(HTS221_ReadReg(HTS221_CTRL_REG1, 1, &tmp))\n\t\treturn HTS221_ERROR;\n\n\ttmp &= ~HTS221_PD_MASK;\n\ttmp |= ((uint8_t)status)<<HTS221_PD_BIT;\n\n\tif(HTS221_WriteReg(HTS221_CTRL_REG1, 1, &tmp))\n\t\treturn HTS221_ERROR;\n\n\treturn HTS221_OK;\n}\n\n/**\n* @brief  Get if HTS221 is in active mode or in power down mode.\n* @param  Pointer to the returned value with HTS221 status.\n* @retval Error code [HTS221_OK, HTS221_ERROR].\n*/\nHTS221_Error_et HTS221_Get_PowerDownMode(HTS221_BitStatus_et* status)\n{\n\tuint8_t tmp;\n\n\tif(HTS221_ReadReg(HTS221_CTRL_REG1, 1, &tmp))\n\t\treturn HTS221_ERROR;\n\n\t*status = (HTS221_BitStatus_et)((tmp & HTS221_PD_MASK) >> HTS221_PD_BIT);\n\n\treturn HTS221_OK;\n}\n\n/**\n* @brief  Set the output data rate mode.\n* @param  odr is the output data rate mode.\n*         This parameter is a @ref HTS221_Odr_et.\n* @retval Error code [HTS221_OK, HTS221_ERROR].\n*/\nHTS221_Error_et HTS221_Set_Odr(HTS221_Odr_et odr)\n{\n\tuint8_t tmp;\n\n\tHTS221_assert_param(IS_HTS221_ODR(odr));\n\n\tif(HTS221_ReadReg(HTS221_CTRL_REG1, 1, &tmp))\n\t\treturn HTS221_ERROR;\n\n\ttmp &= ~HTS221_ODR_MASK;\n\ttmp |= (uint8_t)odr;\n\n\tif(HTS221_WriteReg(HTS221_CTRL_REG1, 1, &tmp))\n\t\treturn HTS221_ERROR;\n\n\treturn HTS221_OK;\n}\n\n/**\n* @brief  Get the output data rate mode.\n* @param  Pointer to the returned value with output data rate mode.\n* @retval Error code [HTS221_OK, HTS221_ERROR].\n*/\nHTS221_Error_et HTS221_Get_Odr(HTS221_Odr_et* odr)\n{\n\tuint8_t tmp;\n\n\tif(HTS221_ReadReg(HTS221_CTRL_REG1, 1, &tmp))\n\t\treturn HTS221_ERROR;\n\n\ttmp &= HTS221_ODR_MASK;\n\t*odr = (HTS221_Odr_et)tmp;\n\n\treturn HTS221_OK;\n}\n\n/**\n* @brief  Reboot Memory Content.\n* @param  None.\n* @retval Error code [HTS221_OK, HTS221_ERROR].\n*/\nHTS221_Error_et HTS221_MemoryBoot(void)\n{\n\tuint8_t tmp;\n\n\tif(HTS221_ReadReg(HTS221_CTRL_REG2, 1, &tmp))\n\t\treturn HTS221_ERROR;\n\n\ttmp |= HTS221_BOOT_MASK;\n\n\tif(HTS221_WriteReg(HTS221_CTRL_REG2, 1, &tmp))\n\t\treturn HTS221_ERROR;\n\n\treturn HTS221_OK;\n}\n\n/**\n* @brief  Configure the internal heater.\n* @param  The status of the internal heater [HTS221_ENABLE/HTS221_DISABLE].\n*         This parameter is a @ref HTS221_State_et.\n* @retval Error code [HTS221_OK, HTS221_ERROR]\n*/\nHTS221_Error_et HTS221_Set_HeaterState(HTS221_State_et status)\n{\n\tuint8_t tmp;\n\n\tHTS221_assert_param(IS_HTS221_State(status));\n\n\tif(HTS221_ReadReg(HTS221_CTRL_REG2, 1, &tmp))\n\t\treturn HTS221_ERROR;\n\n\ttmp &= ~HTS221_HEATHER_MASK;\n\ttmp |= ((uint8_t)status)<<HTS221_HEATHER_BIT;\n\n\tif(HTS221_WriteReg(HTS221_CTRL_REG2, 1, &tmp))\n\t\treturn HTS221_ERROR;\n\n\treturn HTS221_OK;\n}\n\n/**\n* @brief  Get the internal heater.\n* @param  Pointer to the returned status of the internal heater [HTS221_ENABLE/HTS221_DISABLE].\n* @retval Error code [HTS221_OK, HTS221_ERROR].\n*/\nHTS221_Error_et HTS221_Get_HeaterState(HTS221_State_et* status)\n{\n\tuint8_t tmp;\n\n\tif(HTS221_ReadReg(HTS221_CTRL_REG2, 1, &tmp))\n\t\treturn HTS221_ERROR;\n\n\t*status = (HTS221_State_et)((tmp & HTS221_HEATHER_MASK) >> HTS221_HEATHER_BIT);\n\n\treturn HTS221_OK;\n}\n\n/**\n* @brief  Set ONE_SHOT bit to start a new conversion (ODR mode has to be 00).\n*         Once the measurement is done, ONE_SHOT bit is self-cleared.\n* @param  None.\n* @retval Error code [HTS221_OK, HTS221_ERROR].\n*/\nHTS221_Error_et HTS221_StartOneShotMeasurement(void)\n{\n\tuint8_t tmp;\n\n\tif(HTS221_ReadReg(HTS221_CTRL_REG2, 1, &tmp))\n\t\treturn HTS221_ERROR;\n\n\ttmp |= HTS221_ONE_SHOT_MASK;\n\n\tif(HTS221_WriteReg(HTS221_CTRL_REG2, 1, &tmp))\n\t\treturn HTS221_ERROR;\n\n\treturn HTS221_OK;\n\n}\n\n/**\n* @brief  Set level configuration of the interrupt pin DRDY.\n* @param  status can be HTS221_LOW_LVL: active level is LOW.\n* @param  status can be HTS221_HIGH_LVL: active level is HIGH.\n*         This parameter is a @ref HTS221_State_et.\n* @retval Error code [HTS221_OK, HTS221_ERROR].\n*/\nHTS221_Error_et HTS221_Set_IrqActiveLevel(HTS221_DrdyLevel_et value)\n{\n\tuint8_t tmp;\n\n\tHTS221_assert_param(IS_HTS221_DrdyLevelType(value));\n\n\tif(HTS221_ReadReg(HTS221_CTRL_REG3, 1, &tmp))\n\t\treturn HTS221_ERROR;\n\n\ttmp &= ~HTS221_DRDY_H_L_MASK;\n\ttmp |= (uint8_t)value;\n\n\tif(HTS221_WriteReg(HTS221_CTRL_REG3, 1, &tmp))\n\t\treturn HTS221_ERROR;\n\n\treturn HTS221_OK;\n}\n\n/**\n* @brief  Get level configuration of the interrupt pin DRDY.\n* @param  Pointer to the returned status of the level configuration [HTS221_ENABLE/HTS221_DISABLE].\n* @retval Error code [HTS221_OK, HTS221_ERROR].\n*/\nHTS221_Error_et HTS221_Get_IrqActiveLevel(HTS221_DrdyLevel_et* value)\n{\n\tuint8_t tmp;\n\n\tif(HTS221_ReadReg(HTS221_CTRL_REG3, 1, &tmp))\n\t\treturn HTS221_ERROR;\n\n\t*value = (HTS221_DrdyLevel_et)(tmp & HTS221_DRDY_H_L_MASK);\n\n\treturn HTS221_OK;\n}\n\n/**\n* @brief  Set Push-pull/open drain configuration for the interrupt pin DRDY.\n* @param  value is the output type configuration.\n*         This parameter is a @ref HTS221_OutputType_et.\n* @retval Error code [HTS221_OK, HTS221_ERROR].\n*/\nHTS221_Error_et HTS221_Set_IrqOutputType(HTS221_OutputType_et value)\n{\n\tuint8_t tmp;\n\n\tHTS221_assert_param(IS_HTS221_OutputType(value));\n\n\tif(HTS221_ReadReg(HTS221_CTRL_REG3, 1, &tmp))\n\t\treturn HTS221_ERROR;\n\n\ttmp &= ~HTS221_PP_OD_MASK;\n\ttmp |= (uint8_t)value;\n\n\tif(HTS221_WriteReg(HTS221_CTRL_REG3, 1, &tmp))\n\t\treturn HTS221_ERROR;\n\n\treturn HTS221_OK;\n}\n\n/**\n* @brief  Get the configuration for the interrupt pin DRDY.\n* @param  Pointer to the returned value with output type configuration.\n* @retval Error code [HTS221_OK, HTS221_ERROR].\n*/\nHTS221_Error_et HTS221_Get_IrqOutputType(HTS221_OutputType_et* value)\n{\n\tuint8_t tmp;\n\n\tif(HTS221_ReadReg(HTS221_CTRL_REG3, 1, &tmp))\n\t\treturn HTS221_ERROR;\n\n\t*value = (HTS221_OutputType_et)(tmp & HTS221_PP_OD_MASK);\n\n\treturn HTS221_OK;\n}\n\n/**\n* @brief  Enable/disable the interrupt mode.\n* @param  status is the enable/disable for the interrupt mode.\n*         This parameter is a @ref HTS221_State_et.\n* @retval Error code [HTS221_OK, HTS221_ERROR].\n*/\nHTS221_Error_et HTS221_Set_IrqEnable(HTS221_State_et status)\n{\n\tuint8_t tmp;\n\n\tHTS221_assert_param(IS_HTS221_State(status));\n\n\tif(HTS221_ReadReg(HTS221_CTRL_REG3, 1, &tmp))\n\t\treturn HTS221_ERROR;\n\n\ttmp &= ~HTS221_DRDY_MASK;\n\ttmp |= ((uint8_t)status)<<HTS221_DRDY_BIT;\n\n\tif(HTS221_WriteReg(HTS221_CTRL_REG3, 1, &tmp))\n\t\treturn HTS221_ERROR;\n\n\treturn HTS221_OK;\n}\n\n/**\n* @brief  Get the interrupt mode.\n* @param  Pointer to the returned status of the interrupt mode configuration [HTS221_ENABLE/HTS221_DISABLE].\n* @retval Error code [HTS221_OK, HTS221_ERROR].\n*/\nHTS221_Error_et HTS221_Get_IrqEnable(HTS221_State_et* status)\n{\n\tuint8_t tmp;\n\n\tif(HTS221_ReadReg(HTS221_CTRL_REG3, 1, &tmp))\n\t\treturn HTS221_ERROR;\n\n\t*status = (HTS221_State_et)((tmp & HTS221_DRDY_MASK) >> HTS221_DRDY_BIT);\n\n\treturn HTS221_OK;\n}\n\n\n#ifdef  USE_FULL_ASSERT_HTS221\n/**\n* @brief  Reports the name of the source file and the source line number\n*         where the assert_param error has occurred.\n* @param file: pointer to the source file name\n* @param line: assert_param error line source number\n* @retval : None\n*/\nvoid HTS221_assert_failed(uint8_t* file, uint32_t line)\n{\n\t/* User can add his own implementation to report the file name and line number */\n\tprintf(\"Wrong parameters value: file %s on line %lu\\r\\n\", file, (unsigned long)line);\n\n\t/* Infinite loop */\n\twhile (1)\n\t{\n\t}\n}\n#endif\n\n/**\n* @brief  Writes data to register in hts221\n*\n* @param RegAddr: register address in hts221\n* @param NumByteToWrite: specify how many bytes of Data to write\n* @param Data: pointer to Data that needs to be written\n* @retval Error code [HTS221_OK, HTS221_ERROR].\n*/\nHTS221_Error_et HTS221_WriteReg(uint8_t RegAddr, uint16_t NumByteToWrite, uint8_t* Data) {\n\n\tuint8_t writeBytes[2];\n\tuint8_t counter;\n\t\n\tfor(counter = 0; counter < NumByteToWrite; counter++) { //Loop through for each byte\n\n\t\twriteBytes[0] = RegAddr+counter;\n\t\twriteBytes[1] = Data[counter];\n\n\t\tAIR_I2C_Write(HTS221_I2C_ADDRESS>>1,writeBytes,2);\n\t}\n\n\treturn HTS221_OK;\n}\n\n/**\n* @brief  Read data from hts221\n*\n* @param RegAddr: register address in hts221\n* @param NumByteToRead: specify how many bytes of Data to read\n* @param Data: pointer to Data location to read to\n* @retval Error code [HTS221_OK, HTS221_ERROR].\n*/\nHTS221_Error_et HTS221_ReadReg(uint8_t RegAddr, uint16_t NumByteToRead, uint8_t* Data) {\n\n\n\tuint8_t writeBytes[1];\n\tuint8_t counter;\n\t\n\tfor(counter = 0; counter < NumByteToRead; counter++) { //Loop through for each byte\n\n\t\twriteBytes[0] = RegAddr+counter;\n\t\tAIR_I2C_Write(HTS221_I2C_ADDRESS>>1,writeBytes,1);\n\t\tAIR_I2C_Read(HTS221_I2C_ADDRESS>>1,Data+(counter*sizeof(uint8_t)),1);\n\n\t}\n\n\treturn HTS221_OK;\n}\n\n\n\n\n/**\n* @}\n*/\n\n/**\n* @}\n*/\n\n/**\n* @}\n*/\n\n/******************* (C) COPYRIGHT 2013 STMicroelectronics *****END OF FILE****/\n"
            },
            "other": {}
        }
    },
    "label": "HTS221 Driver",
    "language": {
        "en": {
            "label": "HTS221 Driver"
        }
    },
    "links": {
        "Datasheet": "http://www.st.com/st-web-ui/static/active/en/resource/technical/document/datasheet/DM00116291.pdf",
        "Product Page": "http://www.st.com/web/en/catalog/sense_power/FM89/SC1718/PF260067",
        "Wiki Page": "https://atmosphere.anaren.com/wiki/HTS221_Driver"
    },
    "manufacturer": "STMicroelectronics",
    "name": "hts221",
    "signature": "",
    "type": "Embedded Library",
    "version": "1.0.0"
}